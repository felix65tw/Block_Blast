<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Block Blast</title>
    <style>
        :root {
            --bg-color: #1a1a24;
            --game-bg: #252530;
            --accent: #ffd700;
            --accent-gradient: linear-gradient(45deg, #FFC107, #FF9800);
        }

        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; 
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 30px 30px;
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #game-wrapper {
            position: relative;
            background-color: var(--game-bg);
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }

        body.desktop #game-wrapper {
            width: 480px;
            height: 85vh;
            max-height: 850px;
            border-radius: 24px;
            border: 4px solid #444;
        }

        body.mobile #game-wrapper {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 0;
            box-shadow: none;
        }

        #ui-header {
            width: 100%;
            padding-top: 10px; 
            padding-bottom: 0px;
            text-align: center;
            pointer-events: none;
            z-index: 5;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
            margin-bottom: 2px;
            cursor: pointer;
            pointer-events: auto;
            transition: transform 0.2s;
        }

        h1:hover {
            transform: scale(1.05);
        }

        .score-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #score {
            font-size: 48px;
            font-weight: 800;
            color: white;
            line-height: 1;
            transition: transform 0.1s;
        }
        #score.pop { transform: scale(1.2); }

        .stats-row-container {
            margin-top: 0px;
            display: flex;
            gap: 12px;
        }

        .live-stats {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 12px;
            border-radius: 20px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.2s;
        }
        
        .live-stats:hover {
            background: rgba(0, 0, 0, 0.5);
            transform: scale(1.05);
        }

        .live-label {
            font-size: 11px;
            color: #aaa;
            letter-spacing: 1px;
            font-weight: 600;
        }

        #live-block-count { font-size: 16px; color: #4CAF50; font-weight: bold; }
        #best-score { font-size: 16px; color: #FFD700; font-weight: bold; }

        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 8px;
            user-select: none;
        }

        #btn-manual-restart {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: transparent;
            color: var(--accent);
            border: 2px solid var(--accent);
            padding: 6px 18px;
            border-radius: 50px;
            font-size: 13px;
            font-weight: bold;
            letter-spacing: 1px;
            cursor: pointer;
            z-index: 50;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            opacity: 0.7;
            user-select: none;
            -webkit-user-select: none;
        }

        body.mobile #btn-manual-restart {
            top: 666px;
            bottom: auto;
        }

        #btn-manual-restart:hover {
            background: var(--accent);
            color: #252530;
            opacity: 1;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
        }

        #btn-manual-restart:active {
            transform: translateX(-50%) scale(0.95);
        }

        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        body.mobile #game-over-overlay {
            top: 5%;
            bottom: 0;
        }
        
        .overlay.show { opacity: 1; }

        .go-title {
            color: #ff5555; 
            font-size: 42px; 
            margin: 0 0 30px 0;
            text-shadow: 0 0 10px rgba(255, 85, 85, 0.3);
            text-align: center;
        }

        .confirm-title {
            color: #FFC107;
            font-size: 32px;
            margin-bottom: 10px;
        }
        .confirm-desc {
            color: #aaa;
            margin-bottom: 40px;
            font-size: 16px;
        }

        .stats-row {
            display: flex;
            gap: 40px;
            margin-bottom: 30px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label { color: #888; font-size: 14px; margin-bottom: 5px; text-transform: uppercase; }
        .stat-value { color: white; font-size: 36px; font-weight: bold; }
        
        #final-blocks { color: #4CAF50; }
        #final-best { color: #FFD700; }

        .btn-restart {
            background: var(--accent-gradient);
            border: none;
            padding: 15px 50px;
            font-size: 20px;
            color: #fff;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.4);
            transform: scale(1);
            transition: transform 0.1s;
            user-select: none;
        }
        .btn-restart:active { transform: scale(0.95); }

        .confirm-actions {
            display: flex;
            gap: 20px;
        }
        .btn-yes { background: linear-gradient(45deg, #FF5252, #FF1744); box-shadow: 0 4px 15px rgba(255, 82, 82, 0.4); }
        .btn-no { background: #444; box-shadow: 0 4px 15px rgba(0,0,0,0.4); }

        #device-info { display: none; }

        .ai-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            z-index: 1000;
            display: none;
            animation: pulse 2s infinite;
            cursor: pointer;
            pointer-events: auto;
        }

        .ai-indicator:hover {
            background: rgba(0, 255, 0, 0.3);
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
    </style>
</head>
<body class="desktop">

    <div id="game-wrapper">
        <div class="ai-indicator" id="ai-indicator" onclick="toggleAIMode()">AI 模式</div>
        
        <div id="ui-header">
            <h1 id="game-title">Block Blast</h1>
            <div class="score-container">
                <span id="score">0</span>
                <div class="stats-row-container">
                    <div class="live-stats" id="blocks-counter">
                        <span class="live-label">BLOCKS</span>
                        <span id="live-block-count">0</span>
                    </div>
                    <div class="live-stats">
                        <span class="live-label">BEST</span>
                        <span id="best-score">0</span>
                    </div>
                </div>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <button id="btn-manual-restart" onclick="showRestartConfirm()">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                <path d="M23 4v6h-6"></path>
                <path d="M1 20v-6h6"></path>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
            RESTART
        </button>

        <div id="confirm-overlay" class="overlay">
            <h2 class="go-title confirm-title">RESTART?</h2>
            <p class="confirm-desc">Progress will be lost.</p>
            <div class="confirm-actions">
                <button class="btn-restart btn-yes" onclick="confirmRestart()">YES</button>
                <button class="btn-restart btn-no" onclick="hideRestartConfirm()">NO</button>
            </div>
        </div>

        <div id="game-over-overlay" class="overlay">
            <h2 class="go-title">NO MOVES</h2>
            <div class="stats-row">
                <div class="stat-item">
                    <span class="stat-label">SCORE</span>
                    <span id="final-score" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">BEST</span>
                    <span id="final-best" class="stat-value">0</span>
                </div>
            </div>
            <div class="stats-row" style="margin-top: -15px; margin-bottom: 30px;">
                <div class="stat-item">
                     <span class="stat-label">BLOCKS CLEARED</span>
                     <span id="final-blocks" class="stat-value" style="font-size: 28px;">0</span>
                </div>
            </div>
            <button class="btn-restart" onclick="resetGame()">Try Again</button>
        </div>
        
        <div id="device-info">Desktop Mode</div>
    </div>

<script>
// ==========================================
// 0. 音效系統 (Web Audio API) - 增強版
// ==========================================
const SoundManager = {
    ctx: null,
    
    init: function() {
        if (!this.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
        }
    },
    
    resume: function() {
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },

    playNote: function(freq, type, time, dur, vol) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        osc.type = type;
        osc.frequency.value = freq;
        
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(vol, time + 0.05); 
        gain.gain.exponentialRampToValueAtTime(0.001, time + dur); 
        
        osc.start(time);
        osc.stop(time + dur);
    },

    playChord: function(freqs, type, time, dur, vol) {
        const singleVol = vol / freqs.length;
        freqs.forEach(f => {
            this.playNote(f, type, time, dur, singleVol);
        });
    },

    // 為每個方塊形狀設計獨特音效（統一音量為0.15）
    playBlockSound: function(shapeIndex) {
        if (!this.ctx) this.init();
        const t = this.ctx.currentTime;
        
        // 根據方塊形狀索引選擇不同音效，音量統一為0.15
        const soundProfiles = [
            // 單格方塊 - 清脆的單音
            { freqs: [523.25], type: 'sine', dur: 0.15, vol: 0.15 },
            // 2格直線 - 上升音階
            { freqs: [523.25, 659.25], type: 'sine', dur: 0.2, vol: 0.15 },
            // 2格L型 - 小三度
            { freqs: [523.25, 622.25], type: 'triangle', dur: 0.18, vol: 0.15 },
            // 3格直線 - 大三和弦
            { freqs: [523.25, 659.25, 783.99], type: 'sine', dur: 0.25, vol: 0.15 },
            // 3格直線豎版 - 小三和弦
            { freqs: [523.25, 622.25, 783.99], type: 'triangle', dur: 0.25, vol: 0.15 },
            // 2x2方塊 - 完全五度
            { freqs: [392.00, 523.25, 587.33], type: 'square', dur: 0.22, vol: 0.15 },
            // 4格直線 - 上升琶音
            { freqs: [392.00, 493.88, 587.33, 698.46], type: 'sawtooth', dur: 0.3, vol: 0.15 },
            // 4格直線豎版 - 下降琶音
            { freqs: [698.46, 587.33, 493.88, 392.00], type: 'sawtooth', dur: 0.3, vol: 0.15 },
            // L型4格 - 小調音階
            { freqs: [523.25, 554.37, 659.25, 698.46], type: 'triangle', dur: 0.28, vol: 0.15 },
            // 反L型4格 - 大調音階
            { freqs: [523.25, 587.33, 659.25, 783.99], type: 'triangle', dur: 0.28, vol: 0.15 },
            // 小L型3格 - 雙音
            { freqs: [659.25, 783.99], type: 'sine', dur: 0.2, vol: 0.15 },
            // Z型4格 - 不諧和音程
            { freqs: [523.25, 622.25, 739.99, 830.61], type: 'sawtooth', dur: 0.25, vol: 0.15 },
            // 反Z型4格 - 另一不諧和音程
            { freqs: [523.25, 659.25, 783.99, 932.33], type: 'sawtooth', dur: 0.25, vol: 0.15 },
            // T型4格 - 掛留和弦
            { freqs: [523.25, 659.25, 783.99], type: 'square', dur: 0.3, vol: 0.15 }
        ];
        
        const profile = soundProfiles[shapeIndex] || soundProfiles[0];
        
        if (profile.freqs.length === 1) {
            this.playNote(profile.freqs[0], profile.type, t, profile.dur, profile.vol);
        } else {
            this.playChord(profile.freqs, profile.type, t, profile.dur, profile.vol);
        }
    },

    // 消除行（統一音量為0.15）
    playClear: function() {
        if (!this.ctx) this.init();
        const t = this.ctx.currentTime;
        const vol = 0.15; // 統一音量
        const type = 'sine'; 
        
        this.playNote(523.25, type, t, 0.4, vol);        
        this.playNote(659.25, type, t + 0.05, 0.4, vol); 
        this.playNote(783.99, type, t + 0.10, 0.4, vol); 
        this.playNote(987.77, type, t + 0.15, 0.5, vol); 
        this.playNote(1046.50, type, t + 0.20, 0.6, vol);
    },

    // 遊戲結束：悲亢和弦版（統一音量為0.15）
    playGameOver: function() {
        if (!this.ctx) this.init();
        const t = this.ctx.currentTime;
        const type = 'sawtooth'; 
        const vol = 0.15; // 統一音量
        
        this.playChord([174.61, 207.65, 349.23], type, t + 0.0, 0.5, vol);
        this.playChord([155.56, 196.00, 311.13], type, t + 0.4, 0.5, vol);
        this.playChord([146.83, 246.94, 293.66], type, t + 0.8, 0.5, vol);
        this.playChord([130.81, 196.00, 311.13], type, t + 1.2, 2.5, vol);
    },

    // AI模式啟動音效（統一音量為0.15）
    playAIStart: function() {
        if (!this.ctx) this.init();
        const t = this.ctx.currentTime;
        const type = 'square';
        const vol = 0.15; // 統一音量
        
        // 科技感上升音階
        this.playNote(523.25, type, t, 0.15, vol);
        this.playNote(659.25, type, t + 0.05, 0.15, vol);
        this.playNote(783.99, type, t + 0.1, 0.15, vol);
        this.playNote(1046.50, type, t + 0.15, 0.2, vol);
        this.playNote(1318.51, type, t + 0.2, 0.25, vol);
    },

    // 旋轉方塊音效（統一音量為0.15）
    playRotateSound: function() {
        if (!this.ctx) this.init();
        const t = this.ctx.currentTime;
        const vol = 0.15; // 統一音量
        
        // 短促的旋轉音效
        this.playNote(659.25, 'sine', t, 0.1, vol);
        this.playNote(783.99, 'sine', t + 0.05, 0.1, vol);
    }
};

// ==========================================
// 1. 設備偵測與 DOM 元素獲取
// ==========================================
const body = document.body;
const infoLabel = document.getElementById('device-info');
const gameTitle = document.getElementById('game-title');
const aiIndicator = document.getElementById('ai-indicator');
const blocksCounter = document.getElementById('blocks-counter');
let isMobile = false;

function checkDevice() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    if (/android|ipad|iphone|ipod/i.test(userAgent) || window.innerWidth < 768) {
        isMobile = true;
        body.classList.remove('desktop');
        body.classList.add('mobile');
        infoLabel.innerText = "Mobile Mode";
    } else {
        isMobile = false;
        body.classList.remove('mobile');
        body.classList.add('desktop');
        infoLabel.innerText = "Desktop Mode";
    }
    resize();
}
window.addEventListener('resize', checkDevice);

// ==========================================
// 2. 遊戲變數定義
// ==========================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const liveBlocksEl = document.getElementById('live-block-count');
const bestScoreEl = document.getElementById('best-score'); 
const goOverlay = document.getElementById('game-over-overlay');
const confirmOverlay = document.getElementById('confirm-overlay');
const finalScoreEl = document.getElementById('final-score');
const finalBlocksEl = document.getElementById('final-blocks');
const finalBestEl = document.getElementById('final-best'); 

const GRID_SIZE = 8;
const COLORS = ["#FF5252", "#4CAF50", "#2196F3", "#FFC107", "#00BCD4", "#E040FB", "#FF9800"];
const SHAPES = [
    [[0,0]], [[0,0],[1,0]], [[0,0],[0,1]], [[0,0],[1,0],[2,0]], [[0,0],[0,1],[0,2]],
    [[0,0],[1,0],[0,1],[1,1]], [[0,0],[1,0],[2,0],[3,0]], [[0,0],[0,1],[0,2],[0,3]],
    [[0,0],[1,0],[2,0],[2,1]], [[0,0],[1,0],[2,0],[0,1]], [[0,0],[0,1],[1,1]],
    [[0,0],[1,0],[1,1],[2,1]], [[1,0],[2,0],[0,1],[1,1]], [[0,0],[1,0],[2,0],[1,1]]
];

// 方塊名稱對照表
const SHAPE_NAMES = [
    "單格", "橫條2", "豎條2", "橫條3", "豎條3",
    "方塊", "橫條4", "豎條4", "L型", "反L型",
    "小L型", "Z型", "反Z型", "T型"
];

let CELL_SIZE = 0, BOARD_W = 0, BOARD_OFFSET_X = 0, BOARD_OFFSET_Y = 20, INVENTORY_Y = 0;
let BLOCK_SCALE = 0.65;

let grid = []; 
let inventory = []; 
let score = 0;
let bestScore = 0; 
let blocksUsed = 0; 
let dragging = null;
let isAIMode = false;
let aiInterval = null;
let titleClickCount = 0;
let lastTitleClickTime = 0;
let isHiddenMode = false;
let blockCounterClickCount = 0;
let lastBlockCounterClickTime = 0;
let rotateButtons = [];

const STORAGE_KEY = 'block_blast_best_score_v1';

let animState = {
    active: false,
    startTime: 0,
    rows: [],
    cols: [],
    duration: 500,
    blockToPlace: null
};

// ==========================================
// 3. 核心初始化
// ==========================================
function resize() {
    const wrapper = document.getElementById('game-wrapper');
    const rect = wrapper.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height - 100; // 從 130 改為 100
    
    const maxBoardWidth = canvas.width - 40;
    const maxBoardHeight = canvas.height * 0.55;
    CELL_SIZE = Math.floor(Math.min(maxBoardWidth, maxBoardHeight) / GRID_SIZE);
    
    BOARD_W = CELL_SIZE * GRID_SIZE;
    BOARD_OFFSET_X = (canvas.width - BOARD_W) / 2;
    BOARD_OFFSET_Y = 7; // 從 20 改為 7
    
    const BUTTON_RESERVE_SPACE = isMobile ? 25 : 50; // 從 30/60 改為 25/50
    const remainingHeight = canvas.height - BUTTON_RESERVE_SPACE - (BOARD_OFFSET_Y + BOARD_W);
    
    // 修改這行：三個方塊與遊戲區的間距改為 17px
    INVENTORY_Y = (BOARD_OFFSET_Y + BOARD_W) + 17; // 直接設為固定間距 17px
    
    draw();
    if(inventory.length > 0) calcInventoryPos();
}

function loadBestScore() {
    const saved = localStorage.getItem(STORAGE_KEY);
    bestScore = saved ? parseInt(saved, 10) : 0;
    bestScoreEl.innerText = bestScore;
}

function initGame() {
    grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
    score = 0;
    blocksUsed = 0;
    isHiddenMode = false;
    blockCounterClickCount = 0;
    
    loadBestScore();
    
    scoreEl.innerText = "0";
    liveBlocksEl.innerText = "0";
    
    goOverlay.style.display = 'none';
    goOverlay.classList.remove('show');
    confirmOverlay.style.display = 'none';
    confirmOverlay.classList.remove('show');

    animState.active = false;
    
    SoundManager.init();

    checkDevice();
    spawnBlocks();
    requestAnimationFrame(loop);
}

function spawnBlocks() {
    inventory = [];
    for(let i=0; i<3; i++) {
        const shapeIndex = Math.floor(Math.random() * SHAPES.length);
        const shape = SHAPES[shapeIndex];
        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
        inventory.push({
            cells: shape, 
            color: color,
            shapeIndex: shapeIndex,
            rotation: 0, // 新增：方塊旋轉狀態 (0, 1, 2, 3 分別代表0°, 90°, 180°, 270°)
            originalCells: shape, // 原始形狀
            x: 0, y: 0, w: 0, h: 0,
            baseScale: BLOCK_SCALE
        });
    }
    calcInventoryPos();
    if(checkGameOver()) setTimeout(endGame, 100); 
}

function calcInventoryPos() {
    const sectionW = canvas.width / 3;
    inventory.forEach((b, i) => {
        if(!b) return;
        
        // 計算旋轉後的尺寸
        let mw = 0, mh = 0;
        const rotatedCells = getRotatedCells(b.originalCells, b.rotation);
        rotatedCells.forEach(([x,y]) => { mw=Math.max(mw,x); mh=Math.max(mh,y); });
        
        const realCell = CELL_SIZE * b.baseScale;
        b.w = (mw+1) * realCell;
        b.h = (mh+1) * realCell;
        b.x = (sectionW * i) + (sectionW - b.w)/2;
        b.y = INVENTORY_Y;
    });
}

// 獲取旋轉後的方塊形狀
function getRotatedCells(cells, rotation) {
    if (rotation === 0) return cells;
    
    // 旋轉矩陣
    let rotated = [...cells];
    
    for (let r = 0; r < rotation; r++) {
        // 順時針旋轉90度
        rotated = rotated.map(([x, y]) => [-y, x]);
        
        // 正規化（確保所有座標為非負）
        const minX = Math.min(...rotated.map(cell => cell[0]));
        const minY = Math.min(...rotated.map(cell => cell[1]));
        
        if (minX < 0 || minY < 0) {
            rotated = rotated.map(([x, y]) => [x - minX, y - minY]);
        }
    }
    
    return rotated;
}

// 旋轉方塊
function rotateBlock(blockIndex) {
    if (!isHiddenMode) return;
    
    const block = inventory[blockIndex];
    if (!block) return;
    
    // 增加旋轉次數 (0 → 1 → 2 → 3 → 0)
    block.rotation = (block.rotation + 1) % 4;
    
    // 更新方塊形狀
    block.cells = getRotatedCells(block.originalCells, block.rotation);
    
    // 重新計算位置
    calcInventoryPos();
    
    // 播放旋轉音效
    SoundManager.playRotateSound();
    
    // 重繪
    draw();
}

// ==========================================
// 4. 遊戲邏輯
// ==========================================
function canPlace(cells, gc, gr) {
    for(let [x,y] of cells) {
        let nc = gc + x;
        let nr = gr + y;
        if(nc < 0 || nc >= GRID_SIZE || nr < 0 || nr >= GRID_SIZE || grid[nr][nc]) {
            return false;
        }
    }
    return true;
}

function tryPlaceBlock(b, gc, gr, invIndex) {
    blocksUsed++;
    liveBlocksEl.innerText = blocksUsed;

    // 播放對應方塊的音效
    if (b.shapeIndex !== undefined) {
        SoundManager.playBlockSound(b.shapeIndex);
    }
    
    b.cells.forEach(([x,y]) => grid[gr+y][gc+x] = b.color);
    
    let rows=[], cols=[];
    
    for(let r=0; r<GRID_SIZE; r++) {
        if(grid[r].every(c => c)) rows.push(r);
    }
    for(let c=0; c<GRID_SIZE; c++) {
        let full=true;
        for(let r=0; r<GRID_SIZE; r++) if(!grid[r][c]) full=false;
        if(full) cols.push(c);
    }
    
    inventory[invIndex] = null;

    if(rows.length > 0 || cols.length > 0) {
        SoundManager.playClear();

        animState.active = true;
        animState.startTime = Date.now();
        animState.rows = rows;
        animState.cols = cols;
        animState.blockToPlace = b;
        setTimeout(finalizeClear, animState.duration);
    } else {
        score += b.cells.length;
        updateScoreDisplay();
        afterTurn();
    }
}

function finalizeClear() {
    animState.rows.forEach(r => grid[r].fill(null));
    animState.cols.forEach(c => { for(let r=0; r<GRID_SIZE; r++) grid[r][c]=null; });
    
    let count = animState.rows.length + animState.cols.length;
    score += count * 10 + (count * (count-1) * 5);
    
    updateScoreDisplay();
    animState.active = false;
    animState.rows = [];
    animState.cols = [];
    
    afterTurn();
}

function afterTurn() {
    if(inventory.every(x => x === null)) spawnBlocks();
    
    if(checkGameOver()) {
        setTimeout(endGame, 500);
    }
}

function updateScoreDisplay() {
    scoreEl.innerText = score;
    scoreEl.classList.remove('pop');
    void scoreEl.offsetWidth;
    scoreEl.classList.add('pop');

    if (score > bestScore) {
        bestScore = score;
        bestScoreEl.innerText = bestScore;
        localStorage.setItem(STORAGE_KEY, bestScore);
    }
}

function checkGameOver() {
    if(animState.active) return false;
    const left = inventory.filter(b => b);
    if(left.length === 0) return false;
    
    for(let b of left) {
        for(let r=0; r<GRID_SIZE; r++) {
            for(let c=0; c<GRID_SIZE; c++) {
                if(canPlace(b.cells, c, r)) return false;
            }
        }
    }
    return true;
}

function endGame() {
    SoundManager.playGameOver();

    if (score > bestScore) {
        bestScore = score;
        localStorage.setItem(STORAGE_KEY, bestScore);
    }

    finalScoreEl.innerText = score;
    finalBestEl.innerText = bestScore;
    finalBlocksEl.innerText = blocksUsed;
    
    goOverlay.style.display = 'flex';
    setTimeout(()=> goOverlay.classList.add('show'), 10);
    
    // AI模式結束
    if (isAIMode) {
        stopAIMode();
    }
}

function resetGame() {
    initGame();
}

function showRestartConfirm() {
    if (!goOverlay.classList.contains('show')) {
        confirmOverlay.style.display = 'flex';
        setTimeout(() => confirmOverlay.classList.add('show'), 10);
    }
}

function hideRestartConfirm() {
    confirmOverlay.classList.remove('show');
    setTimeout(() => {
        confirmOverlay.style.display = 'none';
    }, 300);
}

function confirmRestart() {
    hideRestartConfirm();
    resetGame();
}

// ==========================================
// 5. AI 託管系統
// ==========================================
function toggleAIMode() {
    if (isAIMode) {
        stopAIMode();
    } else {
        startAIMode();
    }
}

function startAIMode() {
    isAIMode = true;
    aiIndicator.style.display = 'block';
    SoundManager.playAIStart();
    
    // AI每1.5秒自動放置一個方塊
    aiInterval = setInterval(() => {
        if (!isAIMode || animState.active || goOverlay.classList.contains('show')) {
            return;
        }
        
        // 找到第一個可用的方塊
        let blockIndex = -1;
        let block = null;
        
        for(let i = 0; i < inventory.length; i++) {
            if (inventory[i]) {
                blockIndex = i;
                block = inventory[i];
                break;
            }
        }
        
        if (blockIndex === -1 || !block) {
            // 沒有方塊可用，生成新方塊
            if (inventory.every(x => x === null)) {
                spawnBlocks();
            }
            return;
        }
        
        // 尋找最佳放置位置
        const bestPlace = findBestPlacement(block);
        
        if (bestPlace) {
            // 模擬拖放效果
            dragging = {
                idx: blockIndex,
                block: block,
                offsetX: 0,
                offsetY: 0,
                currentX: bestPlace.x * CELL_SIZE + BOARD_OFFSET_X + CELL_SIZE/2,
                currentY: bestPlace.y * CELL_SIZE + BOARD_OFFSET_Y + CELL_SIZE/2,
                isTouch: false
            };
            
            // 短暫延遲後放置方塊，讓玩家看到AI選擇的位置
            setTimeout(() => {
                if (canPlace(block.cells, bestPlace.x, bestPlace.y)) {
                    tryPlaceBlock(block, bestPlace.x, bestPlace.y, blockIndex);
                }
                dragging = null;
            }, 300);
        } else {
            // 沒有可放置的位置，檢查遊戲是否結束
            if (checkGameOver()) {
                setTimeout(endGame, 500);
            }
        }
    }, 1500);
}

function stopAIMode() {
    isAIMode = false;
    aiIndicator.style.display = 'none';
    if (aiInterval) {
        clearInterval(aiInterval);
        aiInterval = null;
    }
}

function findBestPlacement(block) {
    let bestScore = -Infinity;
    let bestPosition = null;
    
    // 評估每個可能的位置
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            if (canPlace(block.cells, c, r)) {
                const score = evaluatePlacement(block, c, r);
                if (score > bestScore) {
                    bestScore = score;
                    bestPosition = {x: c, y: r, score: score};
                }
            }
        }
    }
    
    return bestPosition;
}

function evaluatePlacement(block, col, row) {
    let score = 0;
    
    // 暫時放置方塊來評估後果
    const tempGrid = JSON.parse(JSON.stringify(grid));
    
    // 放置方塊
    block.cells.forEach(([x, y]) => {
        tempGrid[row + y][col + x] = block.color;
    });
    
    // 計算潛在消除
    let potentialClears = 0;
    
    // 檢查行
    for (let r = 0; r < GRID_SIZE; r++) {
        if (tempGrid[r].every(cell => cell !== null)) {
            potentialClears++;
        }
    }
    
    // 檢查列
    for (let c = 0; c < GRID_SIZE; c++) {
        let fullColumn = true;
        for (let r = 0; r < GRID_SIZE; r++) {
            if (tempGrid[r][c] === null) {
                fullColumn = false;
                break;
            }
        }
        if (fullColumn) potentialClears++;
    }
    
    // 基礎分數：消除越多越好
    score += potentialClears * 100;
    
    // 位置分數：優先放在邊緣和角落
    if (col === 0 || col === GRID_SIZE-1) score += 5;
    if (row === 0 || row === GRID_SIZE-1) score += 5;
    
    // 與其他方塊相鄰加分（有利於形成消除）
    let adjacency = 0;
    block.cells.forEach(([x, y]) => {
        const r = row + y;
        const c = col + x;
        
        // 檢查上下左右是否有方塊
        if (r > 0 && grid[r-1][c]) adjacency++;
        if (r < GRID_SIZE-1 && grid[r+1][c]) adjacency++;
        if (c > 0 && grid[r][c-1]) adjacency++;
        if (c < GRID_SIZE-1 && grid[r][c+1]) adjacency++;
    });
    
    score += adjacency * 10;
    
    return score;
}

// ==========================================
// 6. 隱藏模式觸發
// ==========================================
blocksCounter.addEventListener('click', function() {
    const now = Date.now();
    
    // 如果距離上次點擊超過1秒，重置計數
    if (now - lastBlockCounterClickTime > 1000) {
        blockCounterClickCount = 0;
    }
    
    blockCounterClickCount++;
    lastBlockCounterClickTime = now;
    
    // 視覺反饋
    this.style.transform = 'scale(1.1)';
    setTimeout(() => {
        this.style.transform = 'scale(1)';
    }, 150);
    
    // 達到6次點擊
    if (blockCounterClickCount >= 6) {
        blockCounterClickCount = 0;
        isHiddenMode = !isHiddenMode;
        
        // 顯示提示
        if (isHiddenMode) {
            liveBlocksEl.innerHTML = '<span style="color:#FFD700">旋轉模式</span>';
            setTimeout(() => {
                liveBlocksEl.innerHTML = blocksUsed;
            }, 2000);
        } else {
            liveBlocksEl.innerHTML = '<span style="color:#4CAF50">正常模式</span>';
            setTimeout(() => {
                liveBlocksEl.innerHTML = blocksUsed;
            }, 2000);
            
            // 重置所有方塊的旋轉狀態
            inventory.forEach(block => {
                if (block) {
                    block.rotation = 0;
                    block.cells = block.originalCells;
                }
            });
        }
        
        calcInventoryPos();
        draw();
    }
});

// ==========================================
// 7. 標題點擊偵測 (連續6次進入AI模式)
// ==========================================
gameTitle.addEventListener('click', function() {
    const now = Date.now();
    
    // 如果距離上次點擊超過1秒，重置計數
    if (now - lastTitleClickTime > 1000) {
        titleClickCount = 0;
    }
    
    titleClickCount++;
    lastTitleClickTime = now;
    
    // 視覺反饋
    gameTitle.style.transform = 'scale(1.1)';
    setTimeout(() => {
        gameTitle.style.transform = 'scale(1)';
    }, 150);
    
    // 達到6次點擊
    if (titleClickCount >= 6) {
        titleClickCount = 0;
        toggleAIMode();
    }
});

// ==========================================
// 8. 輸入事件處理
// ==========================================
function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    const cy = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: cx - rect.left, y: cy - rect.top, isTouch: !!e.touches };
}

function onDown(e) {
    SoundManager.resume();

    if(animState.active) return;
    if(goOverlay.classList.contains('show') || confirmOverlay.classList.contains('show')) return;
    
    const p = getPos(e);
    
    // 檢查是否點擊了旋轉按鈕
    for (let i = 0; i < rotateButtons.length; i++) {
        const btn = rotateButtons[i];
        if (p.x >= btn.x && p.x <= btn.x + btn.w &&
            p.y >= btn.y && p.y <= btn.y + btn.h) {
            e.preventDefault();
            rotateBlock(btn.blockIndex);
            return;
        }
    }
    
    // 檢查是否點擊了方塊
    for(let i=0; i<inventory.length; i++) {
        const b = inventory[i];
        if(!b) continue;
        
        // 擴大點擊區域
        const hitX = b.x - 20, hitY = b.y - 20, hitW = b.w + 40, hitH = b.h + 40;
        
        if(p.x >= hitX && p.x <= hitX+hitW && p.y >= hitY && p.y <= hitY+hitH) {
            e.preventDefault();
            dragging = { 
                idx: i, block: b, 
                offsetX: p.x - b.x, offsetY: p.y - b.y,
                currentX: p.x, currentY: p.y, isTouch: p.isTouch
            };
            break;
        }
    }
}

function onMove(e) {
    if(!dragging) return;
    e.preventDefault();
    const p = getPos(e);
    dragging.currentX = p.x;
    dragging.currentY = p.y;
}

function onUp(e) {
    if(!dragging) return;
    
    const b = dragging.block;
    let visX = dragging.currentX - dragging.offsetX;
    let visY = dragging.currentY - dragging.offsetY;
    if(dragging.isTouch) visY -= 80;

    const relX = visX - BOARD_OFFSET_X;
    const relY = visY - BOARD_OFFSET_Y;
    const gc = Math.round(relX / CELL_SIZE);
    const gr = Math.round(relY / CELL_SIZE);
    
    if(canPlace(b.cells, gc, gr)) {
        tryPlaceBlock(b, gc, gr, dragging.idx);
    }
    dragging = null;
}

canvas.addEventListener('mousedown', onDown);
window.addEventListener('mousemove', onMove);
window.addEventListener('mouseup', onUp);
canvas.addEventListener('touchstart', onDown, {passive: false});
window.addEventListener('touchmove', onMove, {passive: false});
window.addEventListener('touchend', onUp);

// ==========================================
// 9. 繪圖循環
// ==========================================
function drawRoundedRect(ctx, x, y, w, h, r, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, r);
    ctx.fill();
}

function drawBlock(cells, ox, oy, size, color, alpha=1) {
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    
    cells.forEach(([x,y]) => {
        const px = ox + x * size;
        const py = oy + y * size;
        ctx.beginPath();
        ctx.roundRect(px+1, py+1, size-2, size-2, 6);
        ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.beginPath();
        ctx.roundRect(px+1, py+1, size-2, size/2, 6);
        ctx.fill();
        ctx.fillStyle = color;
    });
    ctx.globalAlpha = 1;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 繪製網格背景
    for(let r=0; r<GRID_SIZE; r++) {
        for(let c=0; c<GRID_SIZE; c++) {
            drawRoundedRect(ctx, 
                BOARD_OFFSET_X + c*CELL_SIZE, 
                BOARD_OFFSET_Y + r*CELL_SIZE, 
                CELL_SIZE-2, CELL_SIZE-2, 6, "#333340");
        }
    }
    
    // 繪製已放置的方塊
    for(let r=0; r<GRID_SIZE; r++) {
        for(let c=0; c<GRID_SIZE; c++) {
            if(grid[r][c]) {
                drawRoundedRect(ctx, 
                    BOARD_OFFSET_X + c*CELL_SIZE + 1, 
                    BOARD_OFFSET_Y + r*CELL_SIZE + 1, 
                    CELL_SIZE-4, CELL_SIZE-4, 6, grid[r][c]);
            }
        }
    }
    
    // 繪製消除動畫
    if(animState.active) {
        const elapsed = Date.now() - animState.startTime;
        const alpha = 0.3 + 0.4 * Math.abs(Math.sin(elapsed / 50)); 
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        
        animState.rows.forEach(r => {
            const x = BOARD_OFFSET_X;
            const y = BOARD_OFFSET_Y + r * CELL_SIZE;
            ctx.beginPath();
            ctx.roundRect(x, y, BOARD_W, CELL_SIZE, 6);
            ctx.fill();
        });
        animState.cols.forEach(c => {
            const x = BOARD_OFFSET_X + c * CELL_SIZE;
            const y = BOARD_OFFSET_Y;
            ctx.beginPath();
            ctx.roundRect(x, y, CELL_SIZE, BOARD_W, 6);
            ctx.fill();
        });
    }

    // 清空旋轉按鈕陣列
    rotateButtons = [];
    
    // 計算按鈕安全區域
    const buttonSize = isMobile ? 22 : 24; // 手機版按鈕小一點
    const buttonPadding = 5;
    
    // 繪製庫存方塊
    inventory.forEach((b, i) => {
        if(b && (!dragging || dragging.idx !== i)) {
            const size = CELL_SIZE * b.baseScale;
            drawBlock(b.cells, b.x, b.y, size, b.color);
            
            // 在隱藏模式下繪製旋轉按鈕
            if (isHiddenMode) {
                // 固定位置：方塊右側，垂直居中
                let buttonX = b.x + b.w + buttonPadding;
                let buttonY = b.y + b.h/2 - buttonSize/2;
                
                // 固定位置邏輯：如果右側空間不足，放在左側
                const spaceRight = canvas.width - (b.x + b.w);
                const spaceLeft = b.x;
                
                if (spaceRight < buttonSize + buttonPadding * 2 && spaceLeft >= buttonSize + buttonPadding * 2) {
                    // 右側空間不足但左側足夠，放在左側
                    buttonX = b.x - buttonSize - buttonPadding;
                }
                
                // 如果左右空間都不足，放在方塊內部右上角
                if ((spaceRight < buttonSize + buttonPadding * 2) && (spaceLeft < buttonSize + buttonPadding * 2)) {
                    buttonX = b.x + b.w - buttonSize - 2;
                    buttonY = b.y + 2;
                }
                
                // 保存按鈕資訊供點擊檢測
                rotateButtons.push({
                    x: buttonX,
                    y: buttonY,
                    w: buttonSize,
                    h: buttonSize,
                    blockIndex: i
                });
                
                // 繪製旋轉按鈕背景
                ctx.fillStyle = "rgba(255, 215, 0, 0.9)";
                ctx.beginPath();
                ctx.arc(buttonX + buttonSize/2, buttonY + buttonSize/2, buttonSize/2, 0, Math.PI * 2);
                ctx.fill();
                
                // 繪製旋轉按鈕邊框
                ctx.strokeStyle = "#252530";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(buttonX + buttonSize/2, buttonY + buttonSize/2, buttonSize/2, 0, Math.PI * 2);
                ctx.stroke();
                
                // 繪製旋轉圖標
                ctx.fillStyle = "#252530";
                ctx.font = `bold ${isMobile ? '12px' : '14px'} Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("↻", buttonX + buttonSize/2, buttonY + buttonSize/2);
            }
        }
    });
    
    // 繪製拖曳中的方塊
    if(dragging) {
        const b = dragging.block;
        let dx = dragging.currentX - dragging.offsetX;
        let dy = dragging.currentY - dragging.offsetY;
        if(dragging.isTouch) dy -= 80;
        
        const relX = dx - BOARD_OFFSET_X;
        const relY = dy - BOARD_OFFSET_Y;
        const gc = Math.round(relX / CELL_SIZE);
        const gr = Math.round(relY / CELL_SIZE);
        
        if(canPlace(b.cells, gc, gr)) {
            drawBlock(b.cells, BOARD_OFFSET_X + gc*CELL_SIZE, BOARD_OFFSET_Y + gr*CELL_SIZE, CELL_SIZE, "#FFFFFF", 0.3);
        }
        
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowBlur = 15;
        ctx.shadowOffsetY = 15;
        drawBlock(b.cells, dx, dy, CELL_SIZE, b.color);
        ctx.shadowColor = "transparent";
    }
}

function loop() {
    draw();
    requestAnimationFrame(loop);
}

// ==========================================
// 10. 初始化遊戲
// ==========================================
loadBestScore();
initGame();

// 防止文字選取
document.addEventListener('selectstart', function(e) {
    e.preventDefault();
});

// 防止右鍵選單
document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
});

</script>
</body>
</html>