<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Block Blast</title>
    <style>
        :root {
            --bg-color: #1a1a24;
            --game-bg: #252530;
            --accent: #ffd700;
            --accent-gradient: linear-gradient(45deg, #FFC107, #FF9800);
        }

        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; 
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 30px 30px;
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #game-wrapper {
            position: relative;
            background-color: var(--game-bg);
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }

        body.desktop #game-wrapper {
            width: 480px;
            height: 85vh;
            max-height: 850px;
            border-radius: 24px;
            border: 4px solid #444;
        }

        body.mobile #game-wrapper {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 0;
            box-shadow: none;
        }

        #ui-header {
            width: 100%;
            padding-top: 10px; 
            padding-bottom: 0px;
            text-align: center;
            pointer-events: none;
            z-index: 5;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
            margin-bottom: 2px;
            cursor: pointer;
            pointer-events: auto;
            transition: transform 0.2s;
        }

        h1:hover {
            transform: scale(1.05);
        }

        .score-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #score {
            font-size: 48px;
            font-weight: 800;
            color: white;
            line-height: 1;
            transition: transform 0.1s;
        }
        #score.pop { transform: scale(1.2); }

        .stats-row-container {
            margin-top: 0px;
            display: flex;
            gap: 12px;
        }

        .live-stats {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 12px;
            border-radius: 20px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.2s;
        }
        
        .live-stats:hover {
            background: rgba(0, 0, 0, 0.5);
            transform: scale(1.05);
        }

        .live-label {
            font-size: 11px;
            color: #aaa;
            letter-spacing: 1px;
            font-weight: 600;
        }

        #live-block-count { font-size: 16px; color: #4CAF50; font-weight: bold; }
        #best-score { 
            font-size: 16px; 
            color: #FFD700; 
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 8px;
            user-select: none;
        }

        #btn-manual-restart {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: transparent;
            color: var(--accent);
            border: 2px solid var(--accent);
            padding: 6px 18px;
            border-radius: 50px;
            font-size: 13px;
            font-weight: bold;
            letter-spacing: 1px;
            cursor: pointer;
            z-index: 50;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            opacity: 0.7;
            user-select: none;
            -webkit-user-select: none;
        }

        body.mobile #btn-manual-restart {
            top: 636px;
            bottom: auto;
        }

        #btn-manual-restart:hover {
            background: var(--accent);
            color: #252530;
            opacity: 1;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
        }

        #btn-manual-restart:active {
            transform: translateX(-50%) scale(0.95);
        }

        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        body.mobile #game-over-overlay {
            top: 0%;
            bottom: 0;
            justify-content: flex-start;
            padding-top: 0;
        }
        
        .overlay.show { opacity: 1; }

        .go-title {
            color: #ff5555; 
            font-size: 42px; 
            margin: 0 0 30px 0;
            text-shadow: 0 0 10px rgba(255, 85, 85, 0.3);
            text-align: center;
        }
        
        body.mobile #game-over-overlay .go-title {
            margin-top:26%;
            margin-bottom: 20px;
        }

        .confirm-title {
            color: #FFC107;
            font-size: 32px;
            margin-bottom: 10px;
        }
        .confirm-desc {
            color: #aaa;
            margin-bottom: 40px;
            font-size: 16px;
        }

        .stats-row {
            display: flex;
            gap: 40px;
            margin-bottom: 30px;
        }
        
        body.mobile #game-over-overlay .stats-row {
            margin-bottom: 15px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label { color: #888; font-size: 14px; margin-bottom: 5px; text-transform: uppercase; }
        .stat-value { color: white; font-size: 36px; font-weight: bold; }
        
        #final-blocks { color: #4CAF50; }
        #final-best { color: #FFD700; }

        .btn-restart {
            background: var(--accent-gradient);
            border: none;
            padding: 15px 50px;
            font-size: 20px;
            color: #fff;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.4);
            transform: scale(1);
            transition: transform 0.1s;
            user-select: none;
        }
        .btn-restart:active { transform: scale(0.95); }

        .confirm-actions {
            display: flex;
            gap: 20px;
        }
        .btn-yes { background: linear-gradient(45deg, #FF5252, #FF1744); box-shadow: 0 4px 15px rgba(255, 82, 82, 0.4); }
        .btn-no { background: #444; box-shadow: 0 4px 15px rgba(0,0,0,0.4); }

        #device-info { display: none; }

        .ai-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            z-index: 1000;
            display: none;
            animation: pulse 2s infinite;
            cursor: pointer;
            pointer-events: auto;
        }

        .ai-indicator:hover {
            background: rgba(0, 255, 0, 0.3);
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        .reset-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(0, 0, 0, 0.9);
            color: #ff5555;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 24px;
            font-weight: bold;
            z-index: 1001;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 85, 85, 0.5);
            border: 3px solid #ff5555;
            pointer-events: none;
            transition: transform 0.3s ease-out;
        }
        
        .reset-notification.show {
            transform: translate(-50%, -50%) scale(1);
        }
    </style>
</head>
<body class="desktop">

    <div id="game-wrapper">
        <div class="ai-indicator" id="ai-indicator" onclick="toggleAIMode()">AI 模式</div>
        
        <div id="ui-header">
            <h1 id="game-title">Block Blast</h1>
            <div class="score-container">
                <span id="score">0</span>
                <div class="stats-row-container">
                    <div class="live-stats" id="blocks-counter">
                        <span class="live-label">BLOCKS</span>
                        <span id="live-block-count">0</span>
                    </div>
                    <div class="live-stats">
                        <span class="live-label">BEST</span>
                        <span id="best-score">0</span>
                    </div>
                </div>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <button id="btn-manual-restart" onclick="showRestartConfirm()">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                <path d="M23 4v6h-6"></path>
                <path d="M1 20v-6h6"></path>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
            RESTART
        </button>

        <div id="confirm-overlay" class="overlay">
            <h2 class="go-title confirm-title">RESTART?</h2>
            <p class="confirm-desc">Progress will be lost.</p>
            <div class="confirm-actions">
                <button class="btn-restart btn-yes" onclick="confirmRestart()">YES</button>
                <button class="btn-restart btn-no" onclick="hideRestartConfirm()">NO</button>
            </div>
        </div>

        <div id="game-over-overlay" class="overlay">
            <h2 class="go-title">NO MOVES</h2>
            <div class="stats-row">
                <div class="stat-item">
                    <span class="stat-label">SCORE</span>
                    <span id="final-score" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">BEST</span>
                    <span id="final-best" class="stat-value">0</span>
                </div>
            </div>
            <div class="stats-row" style="margin-top: -15px; margin-bottom: 30px;">
                <div class="stat-item">
                     <span class="stat-label">BLOCKS CLEARED</span>
                     <span id="final-blocks" class="stat-value" style="font-size: 28px;">0</span>
                </div>
            </div>
            <button class="btn-restart" onclick="resetGame()">Try Again</button>
        </div>
        
        <div id="device-info">Desktop Mode</div>
    </div>
    
    <!-- 新增：最高分歸零提示 -->
    <div id="reset-notification" class="reset-notification">
        最高分已歸零！
    </div>

<script>
// ==========================================
// 0. 音效系統 (Web Audio API) - 增強版
// ==========================================
const SoundManager = {
    ctx: null,
    
    init: function() {
        if (!this.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
        }
    },
    
    resume: function() {
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },

    playNote: function(freq, type, time, dur, vol) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        osc.type = type;
        osc.frequency.value = freq;
        
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(vol, time + 0.05); 
        gain.gain.exponentialRampToValueAtTime(0.001, time + dur); 
        
        osc.start(time);
        osc.stop(time + dur);
    },

    playChord: function(freqs, type, time, dur, vol) {
        const singleVol = vol / freqs.length;
        freqs.forEach(f => {
            this.playNote(f, type, time, dur, singleVol);
        });
    },

    // 為每個方塊形狀設計獨特音效（統一音量為0.15）
    playBlockSound: function(shapeIndex) {
        if (!this.ctx) this.init();
        const t = this.ctx.currentTime;
        
        // 根據方塊形狀索引選擇不同音效，音量統一為0.15
        const soundProfiles = [
            // 單格方塊 - 清脆的單音
            { freqs: [523.25], type: 'sine', dur: 0.15, vol: 0.15 },
            // 2格直線 - 上升音階
            { freqs: [523.25, 659.25], type: 'sine', dur: 0.2, vol: 0.15 },
            // 2格L型 - 小三度
            { freqs: [523.25, 622.25], type: 'triangle', dur: 0.18, vol: 0.15 },
            // 3格直線 - 大三和弦
            { freqs: [523.25, 659.25, 783.99], type: 'sine', dur: 0.25, vol: 0.15 },
            // 3格直線豎版 - 小三和弦
            { freqs: [523.25, 622.25, 783.99], type: 'triangle', dur: 0.25, vol: 0.15 },
            // 2x2方塊 - 完全五度
            { freqs: [392.00, 523.25, 587.33], type: 'square', dur: 0.22, vol: 0.15 },
            // 4格直線 - 上升琶音
            { freqs: [392.00, 493.88, 587.33, 698.46], type: 'sawtooth', dur: 0.3, vol: 0.15 },
            // 4格直線豎版 - 下降琶音
            { freqs: [698.46, 587.33, 493.88, 392.00], type: 'sawtooth', dur: 0.3, vol: 0.15 },
            // L型4格 - 小調音階
            { freqs: [523.25, 554.37, 659.25, 698.46], type: 'triangle', dur: 0.28, vol: 0.15 },
            // 反L型4格 - 大調音階
            { freqs: [523.25, 587.33, 659.25, 783.99], type: 'triangle', dur: 0.28, vol: 0.15 },
            // 小L型3格 - 雙音
            { freqs: [659.25, 783.99], type: 'sine', dur: 0.2, vol: 0.15 },
            // Z型4格 - 不諧和音程
            { freqs: [523.25, 622.25, 739.99, 830.61], type: 'sawtooth', dur: 0.25, vol: 0.15 },
            // 反Z型4格 - 另一不諧和音程
            { freqs: [523.25, 659.25, 783.99, 932.33], type: 'sawtooth', dur: 0.25, vol: 0.15 },
            // T型4格 - 掛留和弦
            { freqs: [523.25, 659.25, 783.99], type: 'square', dur: 0.3, vol: 0.15 }
        ];
        
        const profile = soundProfiles[shapeIndex] || soundProfiles[0];
        
        if (profile.freqs.length === 1) {
            this.playNote(profile.freqs[0], profile.type, t, profile.dur, profile.vol);
        } else {
            this.playChord(profile.freqs, profile.type, t, profile.dur, profile.vol);
        }
    },

    // 消除行（統一音量為0.15）
    playClear: function() {
        if (!this.ctx) this.init();
        const t = this.ctx.currentTime;
        const vol = 0.15;
        const type = 'sine'; 
        
        this.playNote(523.25, type, t, 0.4, vol);        
        this.playNote(659.25, type, t + 0.05, 0.4, vol); 
        this.playNote(783.99, type, t + 0.10, 0.4, vol); 
        this.playNote(987.77, type, t + 0.15, 0.5, vol); 
        this.playNote(1046.50, type, t + 0.20, 0.6, vol);
    },

    // 遊戲結束：悲亢和弦版（統一音量為0.15）
    playGameOver: function() {
        if (!this.ctx) this.init();
        const t = this.ctx.currentTime;
        const type = 'sawtooth'; 
        const vol = 0.15;
        
        this.playChord([174.61, 207.65, 349.23], type, t + 0.0, 0.5, vol);
        this.playChord([155.56, 196.00, 311.13], type, t + 0.4, 0.5, vol);
        this.playChord([146.83, 246.94, 293.66], type, t + 0.8, 0.5, vol);
        this.playChord([130.81, 196.00, 311.13], type, t + 1.2, 2.5, vol);
    },

    // AI模式啟動音效（統一音量為0.15）
    playAIStart: function() {
        if (!this.ctx) this.init();
        const t = this.ctx.currentTime;
        const type = 'square';
        const vol = 0.15;
        
        this.playNote(523.25, type, t, 0.15, vol);
        this.playNote(659.25, type, t + 0.05, 0.15, vol);
        this.playNote(783.99, type, t + 0.1, 0.15, vol);
        this.playNote(1046.50, type, t + 0.15, 0.2, vol);
        this.playNote(1318.51, type, t + 0.2, 0.25, vol);
    },

    // 旋轉方塊音效（統一音量為0.15）
    playRotateSound: function() {
        if (!this.ctx) this.init();
        const t = this.ctx.currentTime;
        const vol = 0.15;
        
        this.playNote(659.25, 'sine', t, 0.1, vol);
        this.playNote(783.99, 'sine', t + 0.05, 0.1, vol);
    },

    // 炸彈爆炸音效（統一音量為0.15）
    playBombSound: function() {
        if (!this.ctx) this.init();
        const t = this.ctx.currentTime;
        const type = 'square';
        const vol = 0.15;
        
        this.playChord([87.31, 174.61, 349.23], type, t, 0.3, vol);
        this.playChord([698.46, 1046.50, 1567.98], type, t + 0.1, 0.2, vol * 1.5);
        this.playNote(523.25, 'sine', t + 0.2, 0.4, vol * 0.8);
    },
    
    // 最高分歸零音效
    playResetSound: function() {
        if (!this.ctx) this.init();
        const t = this.ctx.currentTime;
        const type = 'sawtooth';
        const vol = 0.15;
        
        this.playNote(1046.50, type, t, 0.2, vol);
        this.playNote(783.99, type, t + 0.1, 0.2, vol);
        this.playNote(523.25, type, t + 0.2, 0.2, vol);
        this.playNote(349.23, type, t + 0.3, 0.3, vol);
        this.playNote(174.61, type, t + 0.4, 0.5, vol);
    }
};

// ==========================================
// 1. 設備偵測與 DOM 元素獲取
// ==========================================
const body = document.body;
const infoLabel = document.getElementById('device-info');
const gameTitle = document.getElementById('game-title');
const aiIndicator = document.getElementById('ai-indicator');
const blocksCounter = document.getElementById('blocks-counter');
const bestScoreEl = document.getElementById('best-score');
const resetNotification = document.getElementById('reset-notification');
let isMobile = false;

function checkDevice() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    if (/android|ipad|iphone|ipod/i.test(userAgent) || window.innerWidth < 768) {
        isMobile = true;
        body.classList.remove('desktop');
        body.classList.add('mobile');
        infoLabel.innerText = "Mobile Mode";
    } else {
        isMobile = false;
        body.classList.remove('mobile');
        body.classList.add('desktop');
        infoLabel.innerText = "Desktop Mode";
    }
    resize();
}
window.addEventListener('resize', checkDevice);

// ==========================================
// 2. 遊戲變數定義
// ==========================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const liveBlocksEl = document.getElementById('live-block-count');
const goOverlay = document.getElementById('game-over-overlay');
const confirmOverlay = document.getElementById('confirm-overlay');
const finalScoreEl = document.getElementById('final-score');
const finalBlocksEl = document.getElementById('final-blocks');
const finalBestEl = document.getElementById('final-best'); 

const GRID_SIZE = 8;
const COLORS = ["#FF5252", "#4CAF50", "#2196F3", "#FFC107", "#00BCD4", "#E040FB", "#FF9800"];
const SHAPES = [
    [[0,0]], [[0,0],[1,0]], [[0,0],[0,1]], [[0,0],[1,0],[2,0]], [[0,0],[0,1],[0,2]],
    [[0,0],[1,0],[0,1],[1,1]], [[0,0],[1,0],[2,0],[3,0]], [[0,0],[0,1],[0,2],[0,3]],
    [[0,0],[1,0],[2,0],[2,1]], [[0,0],[1,0],[2,0],[0,1]], [[0,0],[0,1],[1,1]],
    [[0,0],[1,0],[1,1],[2,1]], [[1,0],[2,0],[0,1],[1,1]], [[0,0],[1,0],[2,0],[1,1]]
];

const SHAPE_NAMES = [
    "單格", "橫條2", "豎條2", "橫條3", "豎條3",
    "方塊", "橫條4", "豎條4", "L型", "反L型",
    "小L型", "Z型", "反Z型", "T型"
];

let CELL_SIZE = 0, BOARD_W = 0, BOARD_OFFSET_X = 0, BOARD_OFFSET_Y = 20, INVENTORY_Y = 0;
let BLOCK_SCALE = 0.65;

let grid = []; 
let inventory = []; 
let score = 0;
let bestScore = 0; 
let blocksUsed = 0; 
let dragging = null;
let isAIMode = false;
let aiInterval = null;
let titleClickCount = 0;
let lastTitleClickTime = 0;
let isHiddenMode = false;
let blockCounterClickCount = 0;
let lastBlockCounterClickTime = 0;
let bestScoreClickCount = 0;
let lastBestScoreClickTime = 0;
let rotateButtons = [];

const STORAGE_KEY = 'block_blast_best_score_v1';

let animState = {
    active: false,
    startTime: 0,
    rows: [],
    cols: [],
    duration: 500,
    blockToPlace: null
};

let bombReady = false;
let nextBombScore = 500;

let animations = {
    rippleEffects: [],
    chainEffects: [],
    particleEffects: [],
    bombExplosions: []
};

// ==========================================
// 3. 動畫效果系統 - 優化版
// ==========================================
class RippleEffect {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.radius = 5;
        this.maxRadius = CELL_SIZE * 1.5;
        this.life = 1.0;
        this.speed = 0.05;
    }
    
    update() {
        this.radius += 2;
        this.life -= this.speed;
        return this.life > 0;
    }
    
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.life * 0.7;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }
}

class ChainEffect {
    constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.life = 1.0;
        this.speed = 0.03;
        this.glowSize = 0;
        this.maxGlowSize = 20;
    }
    
    update() {
        this.glowSize += 1.5;
        this.life -= this.speed;
        return this.life > 0;
    }
    
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.life * 0.8;
        
        const gradient = ctx.createRadialGradient(
            this.x + this.width/2, this.y + this.height/2, 0,
            this.x + this.width/2, this.y + this.height/2, this.glowSize
        );
        gradient.addColorStop(0, 'rgba(255, 255, 100, 0.9)');
        gradient.addColorStop(0.7, 'rgba(255, 200, 50, 0.5)');
        gradient.addColorStop(1, 'rgba(255, 150, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(
            this.x - this.glowSize, 
            this.y - this.glowSize, 
            this.width + this.glowSize * 2, 
            this.height + this.glowSize * 2
        );
        
        ctx.restore();
    }
}

// 優化的粒子類別 - 先亮後暗
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        
        // 計算更亮的顏色版本
        const brightColor = this.getBrightColor(color);
        this.startColor = brightColor;
        this.endColor = color;
        
        this.size = Math.random() * 6 + 3;
        this.speedX = Math.random() * 8 - 4;
        this.speedY = Math.random() * 8 - 4;
        this.life = 1.0;
        this.decay = Math.random() * 0.04 + 0.02;
        this.gravity = 0.15;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = Math.random() * 0.1 - 0.05;
        
        this.colorProgress = 0;
        this.colorChangeSpeed = 0.03;
    }
    
    getBrightColor(color) {
        let r, g, b;
        
        if (color.startsWith('#')) {
            r = parseInt(color.slice(1, 3), 16);
            g = parseInt(color.slice(3, 5), 16);
            b = parseInt(color.slice(5, 7), 16);
        } else if (color.startsWith('rgb')) {
            const match = color.match(/(\d+),\s*(\d+),\s*(\d+)/);
            r = parseInt(match[1]);
            g = parseInt(match[2]);
            b = parseInt(match[3]);
        } else {
            return '#FFFFFF';
        }
        
        const brightnessFactor = 1.8;
        r = Math.min(255, Math.floor(r * brightnessFactor));
        g = Math.min(255, Math.floor(g * brightnessFactor));
        b = Math.min(255, Math.floor(b * brightnessFactor));
        
        const whiteFactor = 0.3;
        r = Math.min(255, Math.floor(r + (255 - r) * whiteFactor));
        g = Math.min(255, Math.floor(g + (255 - g) * whiteFactor));
        b = Math.min(255, Math.floor(b + (255 - b) * whiteFactor));
        
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.speedY += this.gravity;
        this.life -= this.decay;
        this.rotation += this.rotationSpeed;
        
        if (this.colorProgress < 1) {
            this.colorProgress = Math.min(1, this.colorProgress + this.colorChangeSpeed);
        }
        
        return this.life > 0;
    }
    
    mixColors(color1, color2, ratio) {
        const r1 = parseInt(color1.slice(1, 3), 16) || 255;
        const g1 = parseInt(color1.slice(3, 5), 16) || 255;
        const b1 = parseInt(color1.slice(5, 7), 16) || 255;
        
        const r2 = parseInt(color2.slice(1, 3), 16) || 255;
        const g2 = parseInt(color2.slice(3, 5), 16) || 255;
        const b2 = parseInt(color2.slice(5, 7), 16) || 255;
        
        const r = Math.floor(r1 * (1 - ratio) + r2 * ratio);
        const g = Math.floor(g1 * (1 - ratio) + g2 * ratio);
        const b = Math.floor(b1 * (1 - ratio) + b2 * ratio);
        
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    draw(ctx) {
        ctx.save();
        
        let currentColor;
        if (this.colorProgress < 1) {
            currentColor = this.mixColors(this.startColor, this.endColor, this.colorProgress);
        } else {
            currentColor = this.endColor;
        }
        
        ctx.shadowColor = currentColor;
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        ctx.globalAlpha = this.life;
        ctx.fillStyle = currentColor;
        
        if (this.size > 4) {
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            
            if (Math.random() > 0.5) {
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
            } else {
                ctx.beginPath();
                ctx.moveTo(0, -this.size/2);
                ctx.lineTo(this.size/2, 0);
                ctx.lineTo(0, this.size/2);
                ctx.lineTo(-this.size/2, 0);
                ctx.closePath();
                ctx.fill();
            }
        } else {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
    }
}

class BombExplosion {
    constructor(centerX, centerY) {
        this.centerX = centerX;
        this.centerY = centerY;
        this.radius = 5;
        this.maxRadius = CELL_SIZE * 2.2;
        this.life = 1.0;
        this.speed = 0.07;
        this.particles = [];
        
        for (let i = 0; i < 50; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5 + 3;
            
            const particle = new Particle(
                centerX, 
                centerY, 
                i % 3 === 0 ? '#FFFF00' : '#FFA500'
            );
            
            particle.speedX = Math.cos(angle) * speed;
            particle.speedY = Math.sin(angle) * speed;
            particle.size = Math.random() * 8 + 4;
            particle.decay = Math.random() * 0.03 + 0.02;
            particle.colorChangeSpeed = 0.05;
            particle.startColor = '#FFFFFF';
            particle.endColor = i % 3 === 0 ? '#FFFF00' : '#FFA500';
            
            this.particles.push(particle);
        }
    }
    
    update() {
        this.radius += 4.5;
        this.life -= this.speed;
        
        for (let i = this.particles.length - 1; i >= 0; i--) {
            if (!this.particles[i].update()) {
                this.particles.splice(i, 1);
            }
        }
        
        return this.life > 0 || this.particles.length > 0;
    }
    
    draw(ctx) {
        ctx.save();
        
        if (this.life > 0) {
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 20;
            ctx.globalAlpha = this.life * 0.8;
            ctx.strokeStyle = '#FFFF00';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(this.centerX, this.centerY, this.radius, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.shadowColor = '#FF9800';
            ctx.shadowBlur = 15;
            ctx.globalAlpha = this.life * 0.6;
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.centerX, this.centerY, this.radius * 0.8, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.shadowColor = '#FFFFFF';
            ctx.shadowBlur = 30;
            ctx.globalAlpha = this.life;
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(this.centerX, this.centerY, this.radius * 0.3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
        
        this.particles.forEach(p => p.draw(ctx));
    }
}

// ==========================================
// 4. 核心初始化
// ==========================================
function resize() {
    const wrapper = document.getElementById('game-wrapper');
    const rect = wrapper.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height - 100;
    
    const maxBoardWidth = canvas.width - 40;
    const maxBoardHeight = canvas.height * 0.55;
    CELL_SIZE = Math.floor(Math.min(maxBoardWidth, maxBoardHeight) / GRID_SIZE);
    
    BOARD_W = CELL_SIZE * GRID_SIZE;
    BOARD_OFFSET_X = (canvas.width - BOARD_W) / 2;
    BOARD_OFFSET_Y = 7;
    
    const BUTTON_RESERVE_SPACE = isMobile ? 25 : 50;
    const remainingHeight = canvas.height - BUTTON_RESERVE_SPACE - (BOARD_OFFSET_Y + BOARD_W);
    
    INVENTORY_Y = (BOARD_OFFSET_Y + BOARD_W) + 17;
    
    draw();
    if(inventory.length > 0) calcInventoryPos();
}

function loadBestScore() {
    const saved = localStorage.getItem(STORAGE_KEY);
    bestScore = saved ? parseInt(saved, 10) : 0;
    bestScoreEl.innerText = bestScore;
    finalBestEl.innerText = bestScore;
}

function initGame() {
    grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
    score = 0;
    blocksUsed = 0;
    isHiddenMode = false;
    blockCounterClickCount = 0;
    
    bombReady = false;
    nextBombScore = 500;
    
    animations = {
        rippleEffects: [],
        chainEffects: [],
        particleEffects: [],
        bombExplosions: []
    };
    
    loadBestScore();
    
    scoreEl.innerText = "0";
    liveBlocksEl.innerText = "0";
    
    goOverlay.style.display = 'none';
    goOverlay.classList.remove('show');
    confirmOverlay.style.display = 'none';
    confirmOverlay.classList.remove('show');

    animState.active = false;
    
    SoundManager.init();

    checkDevice();
    spawnBlocks();
    requestAnimationFrame(loop);
}

function spawnBlocks() {
    inventory = [];
    
    let bombAdded = false;
    if (bombReady) {
        inventory.push({
            cells: [[0,0]], 
            color: "#FFD700",
            shapeIndex: 0,
            rotation: 0,
            originalCells: [[0,0]],
            x: 0, y: 0, w: 0, h: 0,
            baseScale: BLOCK_SCALE,
            isBomb: true
        });
        bombAdded = true;
        bombReady = false;
    }
    
    const blocksToGenerate = bombAdded ? 2 : 3;
    for(let i=0; i<blocksToGenerate; i++) {
        const shapeIndex = Math.floor(Math.random() * SHAPES.length);
        const shape = SHAPES[shapeIndex];
        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
        inventory.push({
            cells: shape, 
            color: color,
            shapeIndex: shapeIndex,
            rotation: 0,
            originalCells: shape,
            x: 0, y: 0, w: 0, h: 0,
            baseScale: BLOCK_SCALE,
            isBomb: false
        });
    }
    
    calcInventoryPos();
    if(checkGameOver()) setTimeout(endGame, 100); 
}

function calcInventoryPos() {
    const sectionW = canvas.width / 3;
    inventory.forEach((b, i) => {
        if(!b) return;
        
        let mw = 0, mh = 0;
        const rotatedCells = getRotatedCells(b.originalCells, b.rotation);
        rotatedCells.forEach(([x,y]) => { mw=Math.max(mw,x); mh=Math.max(mh,y); });
        
        const realCell = CELL_SIZE * b.baseScale;
        b.w = (mw+1) * realCell;
        b.h = (mh+1) * realCell;
        b.x = (sectionW * i) + (sectionW - b.w)/2;
        b.y = INVENTORY_Y;
    });
}

function getRotatedCells(cells, rotation) {
    if (rotation === 0) return cells;
    
    let rotated = [...cells];
    
    for (let r = 0; r < rotation; r++) {
        rotated = rotated.map(([x, y]) => [-y, x]);
        
        const minX = Math.min(...rotated.map(cell => cell[0]));
        const minY = Math.min(...rotated.map(cell => cell[1]));
        
        if (minX < 0 || minY < 0) {
            rotated = rotated.map(([x, y]) => [x - minX, y - minY]);
        }
    }
    
    return rotated;
}

function rotateBlock(blockIndex) {
    if (!isHiddenMode) return;
    
    const block = inventory[blockIndex];
    if (!block || block.isBomb) return;
    
    block.rotation = (block.rotation + 1) % 4;
    block.cells = getRotatedCells(block.originalCells, block.rotation);
    
    calcInventoryPos();
    SoundManager.playRotateSound();
    draw();
}

// ==========================================
// 5. 遊戲邏輯
// ==========================================
function canPlace(cells, gc, gr) {
    for(let [x,y] of cells) {
        let nc = gc + x;
        let nr = gr + y;
        if(nc < 0 || nc >= GRID_SIZE || nr < 0 || nr >= GRID_SIZE || grid[nr][nc]) {
            return false;
        }
    }
    return true;
}

function tryPlaceBlock(b, gc, gr, invIndex) {
    blocksUsed++;
    liveBlocksEl.innerText = blocksUsed;

    if (b.isBomb) {
        SoundManager.playBombSound();
        
        const centerX = BOARD_OFFSET_X + gc * CELL_SIZE + CELL_SIZE / 2;
        const centerY = BOARD_OFFSET_Y + gr * CELL_SIZE + CELL_SIZE / 2;
        animations.bombExplosions.push(new BombExplosion(centerX, centerY));
        
        let cellsCleared = 0;
        for(let r = Math.max(0, gr-1); r <= Math.min(GRID_SIZE-1, gr+1); r++) {
            for(let c = Math.max(0, gc-1); c <= Math.min(GRID_SIZE-1, gc+1); c++) {
                if(grid[r][c]) {
                    const particleX = BOARD_OFFSET_X + c * CELL_SIZE + CELL_SIZE / 2;
                    const particleY = BOARD_OFFSET_Y + r * CELL_SIZE + CELL_SIZE / 2;
                    for(let i = 0; i < 8; i++) {
                        const particle = new Particle(particleX, particleY, grid[r][c]);
                        particle.speedX = Math.random() * 10 - 5;
                        particle.speedY = Math.random() * 10 - 5;
                        animations.particleEffects.push(particle);
                    }
                    grid[r][c] = null;
                    cellsCleared++;
                }
            }
        }
        
        score += cellsCleared * 3;
        updateScoreDisplay();
        
        inventory[invIndex] = null;
        
        checkBombSpawn();
        
        const centerCellX = BOARD_OFFSET_X + gc * CELL_SIZE + CELL_SIZE / 2;
        const centerCellY = BOARD_OFFSET_Y + gr * CELL_SIZE + CELL_SIZE / 2;
        animations.rippleEffects.push(new RippleEffect(centerCellX, centerCellY, "#FFD700"));
        
        afterTurn();
        return;
    }
    
    if (b.shapeIndex !== undefined) {
        SoundManager.playBlockSound(b.shapeIndex);
    }
    
    b.cells.forEach(([x,y]) => {
        const cellX = BOARD_OFFSET_X + (gc + x) * CELL_SIZE + CELL_SIZE / 2;
        const cellY = BOARD_OFFSET_Y + (gr + y) * CELL_SIZE + CELL_SIZE / 2;
        animations.rippleEffects.push(new RippleEffect(cellX, cellY, b.color));
    });
    
    b.cells.forEach(([x,y]) => grid[gr+y][gc+x] = b.color);
    
    let rows=[], cols=[];
    
    for(let r=0; r<GRID_SIZE; r++) {
        if(grid[r].every(c => c)) rows.push(r);
    }
    for(let c=0; c<GRID_SIZE; c++) {
        let full=true;
        for(let r=0; r<GRID_SIZE; r++) if(!grid[r][c]) full=false;
        if(full) cols.push(c);
    }
    
    inventory[invIndex] = null;

    if(rows.length > 0 || cols.length > 0) {
        SoundManager.playClear();

        animState.active = true;
        animState.startTime = Date.now();
        animState.rows = rows;
        animState.cols = cols;
        animState.blockToPlace = b;
        
        const totalClears = rows.length + cols.length;
        if (totalClears >= 3) {
            if (rows.length > 0) {
                const y = BOARD_OFFSET_Y + rows[0] * CELL_SIZE;
                animations.chainEffects.push(new ChainEffect(
                    BOARD_OFFSET_X, y, BOARD_W, rows.length * CELL_SIZE
                ));
            }
            if (cols.length > 0) {
                const x = BOARD_OFFSET_X + cols[0] * CELL_SIZE;
                animations.chainEffects.push(new ChainEffect(
                    x, BOARD_OFFSET_Y, cols.length * CELL_SIZE, BOARD_W
                ));
            }
        }
        
        setTimeout(finalizeClear, animState.duration);
    } else {
        score += b.cells.length;
        updateScoreDisplay();
        checkBombSpawn();
        afterTurn();
    }
}

function finalizeClear() {
    const particlesPerCell = 12;
    
    animState.rows.forEach(r => {
        for(let c=0; c<GRID_SIZE; c++) {
            if(grid[r][c]) {
                const particleX = BOARD_OFFSET_X + c * CELL_SIZE + CELL_SIZE / 2;
                const particleY = BOARD_OFFSET_Y + r * CELL_SIZE + CELL_SIZE / 2;
                for(let i = 0; i < particlesPerCell; i++) {
                    animations.particleEffects.push(new Particle(particleX, particleY, grid[r][c]));
                }
            }
        }
    });
    
    animState.cols.forEach(c => {
        for(let r=0; r<GRID_SIZE; r++) {
            if(grid[r][c]) {
                const particleX = BOARD_OFFSET_X + c * CELL_SIZE + CELL_SIZE / 2;
                const particleY = BOARD_OFFSET_Y + r * CELL_SIZE + CELL_SIZE / 2;
                for(let i = 0; i < particlesPerCell; i++) {
                    animations.particleEffects.push(new Particle(particleX, particleY, grid[r][c]));
                }
            }
        }
    });
    
    animState.rows.forEach(r => grid[r].fill(null));
    animState.cols.forEach(c => { for(let r=0; r<GRID_SIZE; r++) grid[r][c]=null; });
    
    let count = animState.rows.length + animState.cols.length;
    score += count * 10 + (count * (count-1) * 5);
    
    updateScoreDisplay();
    checkBombSpawn();
    
    animState.active = false;
    animState.rows = [];
    animState.cols = [];
    
    afterTurn();
}

function checkBombSpawn() {
    if (score >= nextBombScore && !bombReady) {
        bombReady = true;
        nextBombScore += 500;
        
        liveBlocksEl.innerHTML = '<span style="color:#FFD700">炸彈準備!</span>';
        setTimeout(() => {
            liveBlocksEl.innerHTML = blocksUsed;
        }, 1500);
    }
}

function afterTurn() {
    if(inventory.every(x => x === null)) spawnBlocks();
    
    if(checkGameOver()) {
        setTimeout(endGame, 500);
    }
}

function updateScoreDisplay() {
    scoreEl.innerText = score;
    scoreEl.classList.remove('pop');
    void scoreEl.offsetWidth;
    scoreEl.classList.add('pop');

    if (score > bestScore) {
        bestScore = score;
        bestScoreEl.innerText = bestScore;
        finalBestEl.innerText = bestScore;
        localStorage.setItem(STORAGE_KEY, bestScore);
    }
}

function checkGameOver() {
    if(animState.active) return false;
    const left = inventory.filter(b => b);
    if(left.length === 0) return false;
    
    for(let b of left) {
        for(let r=0; r<GRID_SIZE; r++) {
            for(let c=0; c<GRID_SIZE; c++) {
                if(canPlace(b.cells, c, r)) return false;
            }
        }
    }
    return true;
}

function endGame() {
    SoundManager.playGameOver();

    if (score > bestScore) {
        bestScore = score;
        localStorage.setItem(STORAGE_KEY, bestScore);
    }

    finalScoreEl.innerText = score;
    finalBestEl.innerText = bestScore;
    finalBlocksEl.innerText = blocksUsed;
    
    goOverlay.style.display = 'flex';
    setTimeout(()=> goOverlay.classList.add('show'), 10);
    
    if (isAIMode) {
        stopAIMode();
    }
}

function resetGame() {
    initGame();
}

function showRestartConfirm() {
    if (!goOverlay.classList.contains('show')) {
        confirmOverlay.style.display = 'flex';
        setTimeout(() => confirmOverlay.classList.add('show'), 10);
    }
}

function hideRestartConfirm() {
    confirmOverlay.classList.remove('show');
    setTimeout(() => {
        confirmOverlay.style.display = 'none';
    }, 300);
}

function confirmRestart() {
    hideRestartConfirm();
    resetGame();
}

// ==========================================
// 6. AI 託管系統
// ==========================================
function toggleAIMode() {
    if (isAIMode) {
        stopAIMode();
    } else {
        startAIMode();
    }
}

function startAIMode() {
    isAIMode = true;
    aiIndicator.style.display = 'block';
    SoundManager.playAIStart();
    
    aiInterval = setInterval(() => {
        if (!isAIMode || animState.active || goOverlay.classList.contains('show')) {
            return;
        }
        
        let blockIndex = -1;
        let block = null;
        
        for(let i = 0; i < inventory.length; i++) {
            if (inventory[i]) {
                blockIndex = i;
                block = inventory[i];
                break;
            }
        }
        
        if (blockIndex === -1 || !block) {
            if (inventory.every(x => x === null)) {
                spawnBlocks();
            }
            return;
        }
        
        const bestPlace = findBestPlacement(block);
        
        if (bestPlace) {
            dragging = {
                idx: blockIndex,
                block: block,
                offsetX: 0,
                offsetY: 0,
                currentX: bestPlace.x * CELL_SIZE + BOARD_OFFSET_X + CELL_SIZE/2,
                currentY: bestPlace.y * CELL_SIZE + BOARD_OFFSET_Y + CELL_SIZE/2,
                isTouch: false
            };
            
            setTimeout(() => {
                if (canPlace(block.cells, bestPlace.x, bestPlace.y)) {
                    tryPlaceBlock(block, bestPlace.x, bestPlace.y, blockIndex);
                }
                dragging = null;
            }, 300);
        } else {
            if (checkGameOver()) {
                setTimeout(endGame, 500);
            }
        }
    }, 1500);
}

function stopAIMode() {
    isAIMode = false;
    aiIndicator.style.display = 'none';
    if (aiInterval) {
        clearInterval(aiInterval);
        aiInterval = null;
    }
}

function findBestPlacement(block) {
    let bestScore = -Infinity;
    let bestPosition = null;
    
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            if (canPlace(block.cells, c, r)) {
                const score = evaluatePlacement(block, c, r);
                if (score > bestScore) {
                    bestScore = score;
                    bestPosition = {x: c, y: r, score: score};
                }
            }
        }
    }
    
    return bestPosition;
}

function evaluatePlacement(block, col, row) {
    let score = 0;
    
    const tempGrid = JSON.parse(JSON.stringify(grid));
    
    block.cells.forEach(([x, y]) => {
        tempGrid[row + y][col + x] = block.color;
    });
    
    let potentialClears = 0;
    
    for (let r = 0; r < GRID_SIZE; r++) {
        if (tempGrid[r].every(cell => cell !== null)) {
            potentialClears++;
        }
    }
    
    for (let c = 0; c < GRID_SIZE; c++) {
        let fullColumn = true;
        for (let r = 0; r < GRID_SIZE; r++) {
            if (tempGrid[r][c] === null) {
                fullColumn = false;
                break;
            }
        }
        if (fullColumn) potentialClears++;
    }
    
    score += potentialClears * 100;
    
    if (col === 0 || col === GRID_SIZE-1) score += 5;
    if (row === 0 || row === GRID_SIZE-1) score += 5;
    
    let adjacency = 0;
    block.cells.forEach(([x, y]) => {
        const r = row + y;
        const c = col + x;
        
        if (r > 0 && grid[r-1][c]) adjacency++;
        if (r < GRID_SIZE-1 && grid[r+1][c]) adjacency++;
        if (c > 0 && grid[r][c-1]) adjacency++;
        if (c < GRID_SIZE-1 && grid[r][c+1]) adjacency++;
    });
    
    score += adjacency * 10;
    
    return score;
}

// ==========================================
// 7. 隱藏模式觸發
// ==========================================
blocksCounter.addEventListener('click', function() {
    const now = Date.now();
    
    if (now - lastBlockCounterClickTime > 1000) {
        blockCounterClickCount = 0;
    }
    
    blockCounterClickCount++;
    lastBlockCounterClickTime = now;
    
    this.style.transform = 'scale(1.1)';
    setTimeout(() => {
        this.style.transform = 'scale(1)';
    }, 150);
    
    if (blockCounterClickCount >= 6) {
        blockCounterClickCount = 0;
        isHiddenMode = !isHiddenMode;
        
        if (isHiddenMode) {
            liveBlocksEl.innerHTML = '<span style="color:#FFD700">旋轉模式</span>';
            setTimeout(() => {
                liveBlocksEl.innerHTML = blocksUsed;
            }, 2000);
        } else {
            liveBlocksEl.innerHTML = '<span style="color:#4CAF50">正常模式</span>';
            setTimeout(() => {
                liveBlocksEl.innerHTML = blocksUsed;
            }, 2000);
            
            inventory.forEach(block => {
                if (block) {
                    block.rotation = 0;
                    block.cells = block.originalCells;
                }
            });
        }
        
        calcInventoryPos();
        draw();
    }
});

// ==========================================
// 8. 標題點擊偵測 (連續6次進入AI模式)
// ==========================================
gameTitle.addEventListener('click', function() {
    const now = Date.now();
    
    if (now - lastTitleClickTime > 1000) {
        titleClickCount = 0;
    }
    
    titleClickCount++;
    lastTitleClickTime = now;
    
    gameTitle.style.transform = 'scale(1.1)';
    setTimeout(() => {
        gameTitle.style.transform = 'scale(1)';
    }, 150);
    
    if (titleClickCount >= 6) {
        titleClickCount = 0;
        toggleAIMode();
    }
});

// ==========================================
// 9. 最高分歸零功能 (連續6次點擊最高分)
// ==========================================
bestScoreEl.addEventListener('click', function() {
    const now = Date.now();
    
    if (now - lastBestScoreClickTime > 1000) {
        bestScoreClickCount = 0;
    }
    
    bestScoreClickCount++;
    lastBestScoreClickTime = now;
    
    this.style.transform = 'scale(1.1)';
    this.style.color = '#ff5555';
    setTimeout(() => {
        this.style.transform = 'scale(1)';
        this.style.color = '#FFD700';
    }, 150);
    
    if (bestScoreClickCount >= 6) {
        bestScoreClickCount = 0;
        
        SoundManager.playResetSound();
        
        bestScore = 0;
        bestScoreEl.innerText = "0";
        finalBestEl.innerText = "0";
        
        localStorage.removeItem(STORAGE_KEY);
        
        resetNotification.style.display = 'block';
        setTimeout(() => {
            resetNotification.classList.add('show');
        }, 10);
        
        setTimeout(() => {
            resetNotification.classList.remove('show');
            setTimeout(() => {
                resetNotification.style.display = 'none';
            }, 300);
        }, 3000);
        
        let flashCount = 0;
        const flashInterval = setInterval(() => {
            bestScoreEl.style.visibility = (bestScoreEl.style.visibility === 'hidden') ? 'visible' : 'hidden';
            flashCount++;
            
            if (flashCount >= 6) {
                clearInterval(flashInterval);
                bestScoreEl.style.visibility = 'visible';
            }
        }, 200);
    }
});

// ==========================================
// 10. 輸入事件處理
// ==========================================
function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    const cy = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: cx - rect.left, y: cy - rect.top, isTouch: !!e.touches };
}

function onDown(e) {
    SoundManager.resume();

    if(animState.active) return;
    if(goOverlay.classList.contains('show') || confirmOverlay.classList.contains('show')) return;
    
    const p = getPos(e);
    
    for (let i = 0; i < rotateButtons.length; i++) {
        const btn = rotateButtons[i];
        if (p.x >= btn.x && p.x <= btn.x + btn.w &&
            p.y >= btn.y && p.y <= btn.y + btn.h) {
            e.preventDefault();
            rotateBlock(btn.blockIndex);
            return;
        }
    }
    
    for(let i=0; i<inventory.length; i++) {
        const b = inventory[i];
        if(!b) continue;
        
        const hitX = b.x - 20, hitY = b.y - 20, hitW = b.w + 40, hitH = b.h + 40;
        
        if(p.x >= hitX && p.x <= hitX+hitW && p.y >= hitY && p.y <= hitY+hitH) {
            e.preventDefault();
            dragging = { 
                idx: i, block: b, 
                offsetX: p.x - b.x, offsetY: p.y - b.y,
                currentX: p.x, currentY: p.y, isTouch: p.isTouch
            };
            break;
        }
    }
}

function onMove(e) {
    if(!dragging) return;
    e.preventDefault();
    const p = getPos(e);
    dragging.currentX = p.x;
    dragging.currentY = p.y;
}

function onUp(e) {
    if(!dragging) return;
    
    const b = dragging.block;
    let visX = dragging.currentX - dragging.offsetX;
    let visY = dragging.currentY - dragging.offsetY;
    if(dragging.isTouch) visY -= 80;

    const relX = visX - BOARD_OFFSET_X;
    const relY = visY - BOARD_OFFSET_Y;
    const gc = Math.round(relX / CELL_SIZE);
    const gr = Math.round(relY / CELL_SIZE);
    
    if(canPlace(b.cells, gc, gr)) {
        tryPlaceBlock(b, gc, gr, dragging.idx);
    }
    dragging = null;
}

canvas.addEventListener('mousedown', onDown);
window.addEventListener('mousemove', onMove);
window.addEventListener('mouseup', onUp);
canvas.addEventListener('touchstart', onDown, {passive: false});
window.addEventListener('touchmove', onMove, {passive: false});
window.addEventListener('touchend', onUp);

// ==========================================
// 11. 繪圖循環
// ==========================================
function drawRoundedRect(ctx, x, y, w, h, r, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, r);
    ctx.fill();
}

function drawBlock(cells, ox, oy, size, color, alpha=1) {
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    
    cells.forEach(([x,y]) => {
        const px = ox + x * size;
        const py = oy + y * size;
        ctx.beginPath();
        ctx.roundRect(px+1, py+1, size-2, size-2, 6);
        ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.beginPath();
        ctx.roundRect(px+1, py+1, size-2, size/2, 6);
        ctx.fill();
        ctx.fillStyle = color;
    });
    ctx.globalAlpha = 1;
}

function drawBombBlock(cells, ox, oy, size, color, alpha=1) {
    ctx.globalAlpha = alpha;
    
    const centerX = ox + size/2;
    const centerY = oy + size/2;
    
    ctx.save();
    ctx.translate(centerX, centerY);
    
    ctx.fillStyle = color;
    for(let i = 0; i < 8; i++) {
        ctx.save();
        ctx.rotate((Math.PI/4) * i);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, -size/2);
        ctx.lineTo(size/8, -size/3);
        ctx.lineTo(-size/8, -size/3);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
    
    ctx.fillStyle = "#FF9800";
    ctx.beginPath();
    ctx.arc(0, 0, size/4, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
    ctx.globalAlpha = 1;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    for(let r=0; r<GRID_SIZE; r++) {
        for(let c=0; c<GRID_SIZE; c++) {
            drawRoundedRect(ctx, 
                BOARD_OFFSET_X + c*CELL_SIZE, 
                BOARD_OFFSET_Y + r*CELL_SIZE, 
                CELL_SIZE-2, CELL_SIZE-2, 6, "#333340");
        }
    }
    
    for(let r=0; r<GRID_SIZE; r++) {
        for(let c=0; c<GRID_SIZE; c++) {
            if(grid[r][c]) {
                drawRoundedRect(ctx, 
                    BOARD_OFFSET_X + c*CELL_SIZE + 1, 
                    BOARD_OFFSET_Y + r*CELL_SIZE + 1, 
                    CELL_SIZE-4, CELL_SIZE-4, 6, grid[r][c]);
            }
        }
    }
    
    if(animState.active) {
        const elapsed = Date.now() - animState.startTime;
        const alpha = 0.3 + 0.4 * Math.abs(Math.sin(elapsed / 50)); 
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        
        animState.rows.forEach(r => {
            const x = BOARD_OFFSET_X;
            const y = BOARD_OFFSET_Y + r * CELL_SIZE;
            ctx.beginPath();
            ctx.roundRect(x, y, BOARD_W, CELL_SIZE, 6);
            ctx.fill();
        });
        animState.cols.forEach(c => {
            const x = BOARD_OFFSET_X + c * CELL_SIZE;
            const y = BOARD_OFFSET_Y;
            ctx.beginPath();
            ctx.roundRect(x, y, CELL_SIZE, BOARD_W, 6);
            ctx.fill();
        });
    }

    rotateButtons = [];
    
    inventory.forEach((b, i) => {
        if(b && (!dragging || dragging.idx !== i)) {
            const size = CELL_SIZE * b.baseScale;
            
            if (b.isBomb) {
                drawBombBlock(b.cells, b.x, b.y, size, b.color);
            } else {
                drawBlock(b.cells, b.x, b.y, size, b.color);
            }
            
            if (isHiddenMode && !b.isBomb) {
                const buttonSize = isMobile ? 22 : 24;
                const buttonPadding = 5;
                
                let buttonX = b.x + b.w + buttonPadding;
                let buttonY = b.y + b.h/2 - buttonSize/2;
                
                const spaceRight = canvas.width - (b.x + b.w);
                const spaceLeft = b.x;
                
                if (spaceRight < buttonSize + buttonPadding * 2 && spaceLeft >= buttonSize + buttonPadding * 2) {
                    buttonX = b.x - buttonSize - buttonPadding;
                }
                
                if ((spaceRight < buttonSize + buttonPadding * 2) && (spaceLeft < buttonSize + buttonPadding * 2)) {
                    buttonX = b.x + b.w - buttonSize - 2;
                    buttonY = b.y + 2;
                }
                
                rotateButtons.push({
                    x: buttonX,
                    y: buttonY,
                    w: buttonSize,
                    h: buttonSize,
                    blockIndex: i
                });
                
                ctx.fillStyle = "rgba(255, 215, 0, 0.9)";
                ctx.beginPath();
                ctx.arc(buttonX + buttonSize/2, buttonY + buttonSize/2, buttonSize/2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = "#252530";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(buttonX + buttonSize/2, buttonY + buttonSize/2, buttonSize/2, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = "#252530";
                ctx.font = `bold ${isMobile ? '12px' : '14px'} Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("↻", buttonX + buttonSize/2, buttonY + buttonSize/2);
            }
        }
    });
    
    drawAnimations();
    
    if(dragging) {
        const b = dragging.block;
        let dx = dragging.currentX - dragging.offsetX;
        let dy = dragging.currentY - dragging.offsetY;
        if(dragging.isTouch) dy -= 80;
        
        const relX = dx - BOARD_OFFSET_X;
        const relY = dy - BOARD_OFFSET_Y;
        const gc = Math.round(relX / CELL_SIZE);
        const gr = Math.round(relY / CELL_SIZE);
        
        if(canPlace(b.cells, gc, gr)) {
            drawBlock(b.cells, BOARD_OFFSET_X + gc*CELL_SIZE, BOARD_OFFSET_Y + gr*CELL_SIZE, CELL_SIZE, "#FFFFFF", 0.3);
        }
        
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowBlur = 15;
        ctx.shadowOffsetY = 15;
        
        if (b.isBomb) {
            drawBombBlock(b.cells, dx, dy, CELL_SIZE, b.color);
        } else {
            drawBlock(b.cells, dx, dy, CELL_SIZE, b.color);
        }
        
        ctx.shadowColor = "transparent";
    }
}

function drawAnimations() {
    for (let i = animations.rippleEffects.length - 1; i >= 0; i--) {
        if (!animations.rippleEffects[i].update()) {
            animations.rippleEffects.splice(i, 1);
        } else {
            animations.rippleEffects[i].draw(ctx);
        }
    }
    
    for (let i = animations.chainEffects.length - 1; i >= 0; i--) {
        if (!animations.chainEffects[i].update()) {
            animations.chainEffects.splice(i, 1);
        } else {
            animations.chainEffects[i].draw(ctx);
        }
    }
    
    for (let i = animations.particleEffects.length - 1; i >= 0; i--) {
        if (!animations.particleEffects[i].update()) {
            animations.particleEffects.splice(i, 1);
        } else {
            animations.particleEffects[i].draw(ctx);
        }
    }
    
    for (let i = animations.bombExplosions.length - 1; i >= 0; i--) {
        if (!animations.bombExplosions[i].update()) {
            animations.bombExplosions.splice(i, 1);
        } else {
            animations.bombExplosions[i].draw(ctx);
        }
    }
}

function loop() {
    draw();
    requestAnimationFrame(loop);
}

// ==========================================
// 12. 初始化遊戲
// ==========================================
loadBestScore();
initGame();

document.addEventListener('selectstart', function(e) {
    e.preventDefault();
});

document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
});

</script>
</body>
</html>