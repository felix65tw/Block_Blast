<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Block Blast - Epic Chords Ver.</title>
    <style>
        :root {
            --bg-color: #1a1a24;
            --game-bg: #252530;
            --accent: #ffd700;
            --accent-gradient: linear-gradient(45deg, #FFC107, #FF9800);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; 
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 30px 30px;
            touch-action: none; 
        }

        #game-wrapper {
            position: relative;
            background-color: var(--game-bg);
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        body.desktop #game-wrapper {
            width: 480px;
            height: 85vh;
            max-height: 850px;
            border-radius: 24px;
            border: 4px solid #444;
        }

        body.mobile #game-wrapper {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 0;
            box-shadow: none;
        }

        #ui-header {
            width: 100%;
            padding-top: 30px; 
            padding-bottom: 10px;
            text-align: center;
            pointer-events: none;
            z-index: 5;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
            margin-bottom: 5px;
        }

        .score-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #score {
            font-size: 56px;
            font-weight: 800;
            color: white;
            line-height: 1;
            transition: transform 0.1s;
        }
        #score.pop { transform: scale(1.2); }

        .stats-row-container {
            margin-top: 8px;
            display: flex;
            gap: 12px;
        }

        .live-stats {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 12px;
            border-radius: 20px;
        }
        
        .live-label {
            font-size: 11px;
            color: #aaa;
            letter-spacing: 1px;
            font-weight: 600;
        }

        #live-block-count { font-size: 16px; color: #4CAF50; font-weight: bold; }
        #best-score { font-size: 16px; color: #FFD700; font-weight: bold; }

        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 8px;
        }

        #btn-manual-restart {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: transparent;
            color: var(--accent);
            border: 2px solid var(--accent);
            padding: 6px 18px;
            border-radius: 50px;
            font-size: 13px;
            font-weight: bold;
            letter-spacing: 1px;
            cursor: pointer;
            z-index: 50;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            opacity: 0.7;
            user-select: none;
            -webkit-user-select: none;
        }

        #btn-manual-restart:hover {
            background: var(--accent);
            color: #252530;
            opacity: 1;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
        }

        #btn-manual-restart:active {
            transform: translateX(-50%) scale(0.95);
        }

        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .overlay.show { opacity: 1; }

        .go-title {
            color: #ff5555; 
            font-size: 42px; 
            margin: 0 0 30px 0;
            text-shadow: 0 0 10px rgba(255, 85, 85, 0.3);
            text-align: center;
        }

        .confirm-title {
            color: #FFC107;
            font-size: 32px;
            margin-bottom: 10px;
        }
        .confirm-desc {
            color: #aaa;
            margin-bottom: 40px;
            font-size: 16px;
        }

        .stats-row {
            display: flex;
            gap: 40px;
            margin-bottom: 30px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label { color: #888; font-size: 14px; margin-bottom: 5px; text-transform: uppercase; }
        .stat-value { color: white; font-size: 36px; font-weight: bold; }
        
        #final-blocks { color: #4CAF50; }
        #final-best { color: #FFD700; }

        .btn-restart {
            background: var(--accent-gradient);
            border: none;
            padding: 15px 50px;
            font-size: 20px;
            color: #fff;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.4);
            transform: scale(1);
            transition: transform 0.1s;
        }
        .btn-restart:active { transform: scale(0.95); }

        .confirm-actions {
            display: flex;
            gap: 20px;
        }
        .btn-yes { background: linear-gradient(45deg, #FF5252, #FF1744); box-shadow: 0 4px 15px rgba(255, 82, 82, 0.4); }
        .btn-no { background: #444; box-shadow: 0 4px 15px rgba(0,0,0,0.4); }

        #device-info { display: none; }
    </style>
</head>
<body class="desktop">

    <div id="game-wrapper">
        <div id="ui-header">
            <h1>Block Blast</h1>
            <div class="score-container">
                <span id="score">0</span>
                <div class="stats-row-container">
                    <div class="live-stats">
                        <span class="live-label">BLOCKS</span>
                        <span id="live-block-count">0</span>
                    </div>
                    <div class="live-stats">
                        <span class="live-label">BEST</span>
                        <span id="best-score">0</span>
                    </div>
                </div>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <button id="btn-manual-restart" onclick="showRestartConfirm()">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                <path d="M23 4v6h-6"></path>
                <path d="M1 20v-6h6"></path>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
            RESTART
        </button>

        <div id="confirm-overlay" class="overlay">
            <h2 class="go-title confirm-title">RESTART?</h2>
            <p class="confirm-desc">Progress will be lost.</p>
            <div class="confirm-actions">
                <button class="btn-restart btn-yes" onclick="confirmRestart()">YES</button>
                <button class="btn-restart btn-no" onclick="hideRestartConfirm()">NO</button>
            </div>
        </div>

        <div id="game-over-overlay" class="overlay">
            <h2 class="go-title">NO MOVES</h2>
            <div class="stats-row">
                <div class="stat-item">
                    <span class="stat-label">SCORE</span>
                    <span id="final-score" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">BEST</span>
                    <span id="final-best" class="stat-value">0</span>
                </div>
            </div>
            <div class="stats-row" style="margin-top: -15px; margin-bottom: 30px;">
                <div class="stat-item">
                     <span class="stat-label">BLOCKS CLEARED</span>
                     <span id="final-blocks" class="stat-value" style="font-size: 28px;">0</span>
                </div>
            </div>
            <button class="btn-restart" onclick="resetGame()">Try Again</button>
        </div>
        
        <div id="device-info">Desktop Mode</div>
    </div>

<script>
// ==========================================
// 0. 音效系統 (Web Audio API)
// ==========================================
const SoundManager = {
    ctx: null,
    
    init: function() {
        if (!this.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
        }
    },
    
    resume: function() {
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },

    // 播放單音
    playNote: function(freq, type, time, dur, vol) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        osc.type = type;
        osc.frequency.value = freq;
        
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(vol, time + 0.05); 
        gain.gain.exponentialRampToValueAtTime(0.001, time + dur); 
        
        osc.start(time);
        osc.stop(time + dur);
    },

    // 新增：播放和弦 (同時播放多個頻率)
    playChord: function(freqs, type, time, dur, vol) {
        // 因為同時播放多個音，音量要除以音符數量，避免爆音
        const singleVol = vol / freqs.length;
        freqs.forEach(f => {
            this.playNote(f, type, time, dur, singleVol);
        });
    },

    // 1. 放置方塊
    playPlace: function() {
        if (!this.ctx) this.init();
        this.playNote(600, 'sine', this.ctx.currentTime, 0.1, 0.1);
    },

    // 2. 消除行
    playClear: function() {
        if (!this.ctx) this.init();
        const t = this.ctx.currentTime;
        const vol = 0.1;
        const type = 'sine'; 
        
        this.playNote(523.25, type, t, 0.4, vol);        
        this.playNote(659.25, type, t + 0.05, 0.4, vol); 
        this.playNote(783.99, type, t + 0.10, 0.4, vol); 
        this.playNote(987.77, type, t + 0.15, 0.5, vol); 
        this.playNote(1046.50, type, t + 0.20, 0.6, vol);
    },

    // 3. 遊戲結束：【悲亢和弦版】
    // 使用 Sawtooth (鋸齒波) 來模擬壯烈的銅管樂
    // 每個步驟播放 3 個音符組成的和弦
    playGameOver: function() {
        if (!this.ctx) this.init();
        const t = this.ctx.currentTime;
        const type = 'sawtooth'; 
        const vol = 0.35; // 總體音量 (內部會再除以3)
        
        // 1. F Minor (F3, Ab3, F4) - 悲劇的開始
        this.playChord([174.61, 207.65, 349.23], type, t + 0.0, 0.5, vol);

        // 2. Eb Major (Eb3, G3, Eb4) - 過渡
        this.playChord([155.56, 196.00, 311.13], type, t + 0.4, 0.5, vol);

        // 3. G Major (D3, B3, D4) - 張力 (Dominant)
        // 注意：B3 是 246.94Hz
        this.playChord([146.83, 246.94, 293.66], type, t + 0.8, 0.5, vol);

        // 4. C Minor (C3, G3, Eb4) - 壯烈的結局
        // 最低音 C3 (130Hz) 是安全範圍，上方疊加 G3 和 Eb4 (悲傷小三度)
        this.playChord([130.81, 196.00, 311.13], type, t + 1.2, 2.5, vol);
    }
};

// ==========================================
// 1. 設備偵測與 DOM 元素獲取
// ==========================================
const body = document.body;
const infoLabel = document.getElementById('device-info');
let isMobile = false;

function checkDevice() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    if (/android|ipad|iphone|ipod/i.test(userAgent) || window.innerWidth < 768) {
        isMobile = true;
        body.classList.remove('desktop');
        body.classList.add('mobile');
        infoLabel.innerText = "Mobile Mode";
    } else {
        isMobile = false;
        body.classList.remove('mobile');
        body.classList.add('desktop');
        infoLabel.innerText = "Desktop Mode";
    }
    resize();
}
window.addEventListener('resize', checkDevice);

// ==========================================
// 2. 遊戲變數定義
// ==========================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const liveBlocksEl = document.getElementById('live-block-count');
const bestScoreEl = document.getElementById('best-score'); 
const goOverlay = document.getElementById('game-over-overlay');
const confirmOverlay = document.getElementById('confirm-overlay');
const finalScoreEl = document.getElementById('final-score');
const finalBlocksEl = document.getElementById('final-blocks');
const finalBestEl = document.getElementById('final-best'); 

const GRID_SIZE = 8;
const COLORS = ["#FF5252", "#4CAF50", "#2196F3", "#FFC107", "#00BCD4", "#E040FB", "#FF9800"];
const SHAPES = [
    [[0,0]], [[0,0],[1,0]], [[0,0],[0,1]], [[0,0],[1,0],[2,0]], [[0,0],[0,1],[0,2]],
    [[0,0],[1,0],[0,1],[1,1]], [[0,0],[1,0],[2,0],[3,0]], [[0,0],[0,1],[0,2],[0,3]],
    [[0,0],[1,0],[2,0],[2,1]], [[0,0],[1,0],[2,0],[0,1]], [[0,0],[0,1],[1,1]],
    [[0,0],[1,0],[1,1],[2,1]], [[1,0],[2,0],[0,1],[1,1]], [[0,0],[1,0],[2,0],[1,1]]
];

let CELL_SIZE = 0, BOARD_W = 0, BOARD_OFFSET_X = 0, BOARD_OFFSET_Y = 20, INVENTORY_Y = 0;
let BLOCK_SCALE = 0.65;

let grid = []; 
let inventory = []; 
let score = 0;
let bestScore = 0; 
let blocksUsed = 0; 
let dragging = null;

const STORAGE_KEY = 'block_blast_best_score_v1';

let animState = {
    active: false,
    startTime: 0,
    rows: [],
    cols: [],
    duration: 500,
    blockToPlace: null
};

// ==========================================
// 3. 核心初始化
// ==========================================
function resize() {
    const wrapper = document.getElementById('game-wrapper');
    const rect = wrapper.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height - 130; 
    
    const maxBoardWidth = canvas.width - 40;
    const maxBoardHeight = canvas.height * 0.55;
    CELL_SIZE = Math.floor(Math.min(maxBoardWidth, maxBoardHeight) / GRID_SIZE);
    
    BOARD_W = CELL_SIZE * GRID_SIZE;
    BOARD_OFFSET_X = (canvas.width - BOARD_W) / 2;
    BOARD_OFFSET_Y = 20;

    const BUTTON_RESERVE_SPACE = 60; 
    const remainingHeight = canvas.height - BUTTON_RESERVE_SPACE - (BOARD_OFFSET_Y + BOARD_W);
    INVENTORY_Y = (BOARD_OFFSET_Y + BOARD_W) + (remainingHeight / 2) - (CELL_SIZE * 1.5);

    draw();
    if(inventory.length > 0) calcInventoryPos();
}

function loadBestScore() {
    const saved = localStorage.getItem(STORAGE_KEY);
    bestScore = saved ? parseInt(saved, 10) : 0;
    bestScoreEl.innerText = bestScore;
}

function initGame() {
    grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
    score = 0;
    blocksUsed = 0;
    
    loadBestScore();
    
    scoreEl.innerText = "0";
    liveBlocksEl.innerText = "0";
    
    goOverlay.style.display = 'none';
    goOverlay.classList.remove('show');
    confirmOverlay.style.display = 'none';
    confirmOverlay.classList.remove('show');

    animState.active = false;
    
    SoundManager.init();

    checkDevice();
    spawnBlocks();
    requestAnimationFrame(loop);
}

function spawnBlocks() {
    inventory = [];
    for(let i=0; i<3; i++) {
        const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
        inventory.push({
            cells: shape, color: color,
            x: 0, y: 0, w: 0, h: 0,
            baseScale: BLOCK_SCALE
        });
    }
    calcInventoryPos();
    if(checkGameOver()) setTimeout(endGame, 100); 
}

function calcInventoryPos() {
    const sectionW = canvas.width / 3;
    inventory.forEach((b, i) => {
        if(!b) return;
        let mw = 0, mh = 0;
        b.cells.forEach(([x,y]) => { mw=Math.max(mw,x); mh=Math.max(mh,y); });
        
        const realCell = CELL_SIZE * b.baseScale;
        b.w = (mw+1) * realCell;
        b.h = (mh+1) * realCell;
        b.x = (sectionW * i) + (sectionW - b.w)/2;
        b.y = INVENTORY_Y;
    });
}

// ==========================================
// 4. 遊戲邏輯
// ==========================================
function canPlace(cells, gc, gr) {
    for(let [x,y] of cells) {
        let nc = gc + x;
        let nr = gr + y;
        if(nc < 0 || nc >= GRID_SIZE || nr < 0 || nr >= GRID_SIZE || grid[nr][nc]) {
            return false;
        }
    }
    return true;
}

function tryPlaceBlock(b, gc, gr, invIndex) {
    blocksUsed++;
    liveBlocksEl.innerText = blocksUsed;

    b.cells.forEach(([x,y]) => grid[gr+y][gc+x] = b.color);
    
    let rows=[], cols=[];
    
    for(let r=0; r<GRID_SIZE; r++) {
        if(grid[r].every(c => c)) rows.push(r);
    }
    for(let c=0; c<GRID_SIZE; c++) {
        let full=true;
        for(let r=0; r<GRID_SIZE; r++) if(!grid[r][c]) full=false;
        if(full) cols.push(c);
    }
    
    inventory[invIndex] = null;

    if(rows.length > 0 || cols.length > 0) {
        SoundManager.playClear();

        animState.active = true;
        animState.startTime = Date.now();
        animState.rows = rows;
        animState.cols = cols;
        animState.blockToPlace = b;
        setTimeout(finalizeClear, animState.duration);
    } else {
        SoundManager.playPlace();

        score += b.cells.length;
        updateScoreDisplay();
        afterTurn();
    }
}

function finalizeClear() {
    animState.rows.forEach(r => grid[r].fill(null));
    animState.cols.forEach(c => { for(let r=0; r<GRID_SIZE; r++) grid[r][c]=null; });
    
    let count = animState.rows.length + animState.cols.length;
    score += count * 10 + (count * (count-1) * 5);
    
    updateScoreDisplay();
    animState.active = false;
    animState.rows = [];
    animState.cols = [];
    
    afterTurn();
}

function afterTurn() {
    if(inventory.every(x => x === null)) spawnBlocks();
    
    if(checkGameOver()) {
        setTimeout(endGame, 500);
    }
}

function updateScoreDisplay() {
    scoreEl.innerText = score;
    scoreEl.classList.remove('pop');
    void scoreEl.offsetWidth;
    scoreEl.classList.add('pop');

    if (score > bestScore) {
        bestScore = score;
        bestScoreEl.innerText = bestScore;
        localStorage.setItem(STORAGE_KEY, bestScore);
    }
}

function checkGameOver() {
    if(animState.active) return false;
    const left = inventory.filter(b => b);
    if(left.length === 0) return false;
    
    for(let b of left) {
        for(let r=0; r<GRID_SIZE; r++) {
            for(let c=0; c<GRID_SIZE; c++) {
                if(canPlace(b.cells, c, r)) return false;
            }
        }
    }
    return true;
}

function endGame() {
    SoundManager.playGameOver();

    if (score > bestScore) {
        bestScore = score;
        localStorage.setItem(STORAGE_KEY, bestScore);
    }

    finalScoreEl.innerText = score;
    finalBestEl.innerText = bestScore;
    finalBlocksEl.innerText = blocksUsed;
    
    goOverlay.style.display = 'flex';
    setTimeout(()=> goOverlay.classList.add('show'), 10);
}

function resetGame() {
    initGame();
}

function showRestartConfirm() {
    if (!goOverlay.classList.contains('show')) {
        confirmOverlay.style.display = 'flex';
        setTimeout(() => confirmOverlay.classList.add('show'), 10);
    }
}

function hideRestartConfirm() {
    confirmOverlay.classList.remove('show');
    setTimeout(() => {
        confirmOverlay.style.display = 'none';
    }, 300);
}

function confirmRestart() {
    hideRestartConfirm();
    resetGame();
}

// ==========================================
// 5. 輸入事件處理
// ==========================================
function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    const cy = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: cx - rect.left, y: cy - rect.top, isTouch: !!e.touches };
}

function onDown(e) {
    SoundManager.resume();

    if(animState.active) return;
    if(goOverlay.classList.contains('show') || confirmOverlay.classList.contains('show')) return;
    
    const p = getPos(e);
    
    for(let i=0; i<inventory.length; i++) {
        const b = inventory[i];
        if(!b) continue;
        const hitX = b.x - 20, hitY = b.y - 20, hitW = b.w + 40, hitH = b.h + 40;
        
        if(p.x >= hitX && p.x <= hitX+hitW && p.y >= hitY && p.y <= hitY+hitH) {
            e.preventDefault();
            dragging = { 
                idx: i, block: b, 
                offsetX: p.x - b.x, offsetY: p.y - b.y,
                currentX: p.x, currentY: p.y, isTouch: p.isTouch
            };
            break;
        }
    }
}

function onMove(e) {
    if(!dragging) return;
    e.preventDefault();
    const p = getPos(e);
    dragging.currentX = p.x;
    dragging.currentY = p.y;
}

function onUp(e) {
    if(!dragging) return;
    
    const b = dragging.block;
    let visX = dragging.currentX - dragging.offsetX;
    let visY = dragging.currentY - dragging.offsetY;
    if(dragging.isTouch) visY -= 80;

    const relX = visX - BOARD_OFFSET_X;
    const relY = visY - BOARD_OFFSET_Y;
    const gc = Math.round(relX / CELL_SIZE);
    const gr = Math.round(relY / CELL_SIZE);
    
    if(canPlace(b.cells, gc, gr)) {
        tryPlaceBlock(b, gc, gr, dragging.idx);
    }
    dragging = null;
}

canvas.addEventListener('mousedown', onDown);
window.addEventListener('mousemove', onMove);
window.addEventListener('mouseup', onUp);
canvas.addEventListener('touchstart', onDown, {passive: false});
window.addEventListener('touchmove', onMove, {passive: false});
window.addEventListener('touchend', onUp);

// ==========================================
// 6. 繪圖循環
// ==========================================
function drawRoundedRect(ctx, x, y, w, h, r, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, r);
    ctx.fill();
}

function drawBlock(cells, ox, oy, size, color, alpha=1) {
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    
    cells.forEach(([x,y]) => {
        const px = ox + x * size;
        const py = oy + y * size;
        ctx.beginPath();
        ctx.roundRect(px+1, py+1, size-2, size-2, 6);
        ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.beginPath();
        ctx.roundRect(px+1, py+1, size-2, size/2, 6);
        ctx.fill();
        ctx.fillStyle = color;
    });
    ctx.globalAlpha = 1;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    for(let r=0; r<GRID_SIZE; r++) {
        for(let c=0; c<GRID_SIZE; c++) {
            drawRoundedRect(ctx, 
                BOARD_OFFSET_X + c*CELL_SIZE, 
                BOARD_OFFSET_Y + r*CELL_SIZE, 
                CELL_SIZE-2, CELL_SIZE-2, 6, "#333340");
        }
    }
    
    for(let r=0; r<GRID_SIZE; r++) {
        for(let c=0; c<GRID_SIZE; c++) {
            if(grid[r][c]) {
                drawRoundedRect(ctx, 
                    BOARD_OFFSET_X + c*CELL_SIZE + 1, 
                    BOARD_OFFSET_Y + r*CELL_SIZE + 1, 
                    CELL_SIZE-4, CELL_SIZE-4, 6, grid[r][c]);
            }
        }
    }
    
    if(animState.active) {
        const elapsed = Date.now() - animState.startTime;
        const alpha = 0.3 + 0.4 * Math.abs(Math.sin(elapsed / 50)); 
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        
        animState.rows.forEach(r => {
            const x = BOARD_OFFSET_X;
            const y = BOARD_OFFSET_Y + r * CELL_SIZE;
            ctx.beginPath();
            ctx.roundRect(x, y, BOARD_W, CELL_SIZE, 6);
            ctx.fill();
        });
        animState.cols.forEach(c => {
            const x = BOARD_OFFSET_X + c * CELL_SIZE;
            const y = BOARD_OFFSET_Y;
            ctx.beginPath();
            ctx.roundRect(x, y, CELL_SIZE, BOARD_W, 6);
            ctx.fill();
        });
    }

    inventory.forEach((b, i) => {
        if(b && (!dragging || dragging.idx !== i)) {
            const size = CELL_SIZE * b.baseScale;
            drawBlock(b.cells, b.x, b.y, size, b.color);
        }
    });
    
    if(dragging) {
        const b = dragging.block;
        let dx = dragging.currentX - dragging.offsetX;
        let dy = dragging.currentY - dragging.offsetY;
        if(dragging.isTouch) dy -= 80;
        
        const relX = dx - BOARD_OFFSET_X;
        const relY = dy - BOARD_OFFSET_Y;
        const gc = Math.round(relX / CELL_SIZE);
        const gr = Math.round(relY / CELL_SIZE);
        
        if(canPlace(b.cells, gc, gr)) {
            drawBlock(b.cells, BOARD_OFFSET_X + gc*CELL_SIZE, BOARD_OFFSET_Y + gr*CELL_SIZE, CELL_SIZE, "#FFFFFF", 0.3);
        }
        
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowBlur = 15;
        ctx.shadowOffsetY = 15;
        drawBlock(b.cells, dx, dy, CELL_SIZE, b.color);
        ctx.shadowColor = "transparent";
    }
}

function loop() {
    draw();
    requestAnimationFrame(loop);
}

loadBestScore();
initGame();

</script>
</body>
</html>