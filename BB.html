<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Block Blast - Live Stats Ver.</title>
    <style>
        :root {
            --bg-color: #1a1a24;
            --game-bg: #252530;
            --accent: #ffd700;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; 
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 30px 30px;
            touch-action: none; 
        }

        #game-wrapper {
            position: relative;
            background-color: var(--game-bg);
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Desktop Mode */
        body.desktop #game-wrapper {
            width: 480px;
            height: 85vh;
            max-height: 850px;
            border-radius: 24px;
            border: 4px solid #444;
        }

        /* Mobile Mode */
        body.mobile #game-wrapper {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 0;
            box-shadow: none;
        }

        #ui-header {
            width: 100%;
            padding-top: 30px; /* 稍微縮小頂部間距以容納新元素 */
            padding-bottom: 10px;
            text-align: center;
            pointer-events: none;
            z-index: 5;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
            margin-bottom: 5px;
        }

        .score-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #score {
            font-size: 56px;
            font-weight: 800;
            color: white;
            line-height: 1;
            transition: transform 0.1s;
        }
        #score.pop { transform: scale(1.2); }

        /* 新增：即時方塊統計樣式 */
        .live-stats {
            margin-top: 5px;
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 12px;
            border-radius: 20px;
        }
        
        .live-label {
            font-size: 12px;
            color: #aaa;
            letter-spacing: 1px;
            font-weight: 600;
        }

        #live-block-count {
            font-size: 18px;
            color: #4CAF50; /* 綠色 */
            font-weight: bold;
        }

        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 8px;
        }

        #device-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: rgba(255,255,255,0.2);
            font-size: 12px;
            pointer-events: none;
        }

        /* --- Game Over Screen Styles --- */
        #game-over-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #game-over-overlay.show { opacity: 1; }

        .go-title {
            color: #ff5555; 
            font-size: 42px; 
            margin: 0 0 30px 0;
            text-shadow: 0 0 10px rgba(255, 85, 85, 0.3);
        }

        .stats-row {
            display: flex;
            gap: 40px;
            margin-bottom: 30px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            color: #888;
            font-size: 14px;
            margin-bottom: 5px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .stat-value {
            color: white;
            font-size: 36px;
            font-weight: bold;
        }
        
        #final-blocks { color: #4CAF50; }

        .btn-restart {
            background: linear-gradient(45deg, #FFC107, #FF9800);
            border: none;
            padding: 15px 50px;
            font-size: 20px;
            color: #fff;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.4);
            transform: scale(1);
            transition: transform 0.1s;
        }
        .btn-restart:active { transform: scale(0.95); }

    </style>
</head>
<body class="desktop">

    <div id="game-wrapper">
        <div id="ui-header">
            <h1>Block Blast</h1>
            <div class="score-container">
                <span id="score">0</span>
                
                <!-- 新增：即時方塊數顯示 -->
                <div class="live-stats">
                    <span class="live-label">BLOCKS</span>
                    <span id="live-block-count">0</span>
                </div>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="game-over-overlay">
            <h2 class="go-title">NO MOVES</h2>
            
            <div class="stats-row">
                <div class="stat-item">
                    <span class="stat-label">SCORE</span>
                    <span id="final-score" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">BLOCKS</span>
                    <span id="final-blocks" class="stat-value">0</span>
                </div>
            </div>

            <button class="btn-restart" onclick="resetGame()">Try Again</button>
        </div>
        
        <div id="device-info">Desktop Mode</div>
    </div>

<script>
// --- 1. 設備偵測 ---
const body = document.body;
const infoLabel = document.getElementById('device-info');
let isMobile = false;

function checkDevice() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    if (/android|ipad|iphone|ipod/i.test(userAgent) || window.innerWidth < 768) {
        isMobile = true;
        body.classList.remove('desktop');
        body.classList.add('mobile');
        infoLabel.innerText = "Mobile Mode";
    } else {
        isMobile = false;
        body.classList.remove('mobile');
        body.classList.add('desktop');
        infoLabel.innerText = "Desktop Mode";
    }
    resize();
}
window.addEventListener('resize', checkDevice);

// --- 2. 遊戲變數 ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const liveBlocksEl = document.getElementById('live-block-count'); // 新增
const goOverlay = document.getElementById('game-over-overlay');
const finalScoreEl = document.getElementById('final-score');
const finalBlocksEl = document.getElementById('final-blocks');

const GRID_SIZE = 8;
const COLORS = ["#FF5252", "#4CAF50", "#2196F3", "#FFC107", "#00BCD4", "#E040FB", "#FF9800"];
const SHAPES = [
    [[0,0]], [[0,0],[1,0]], [[0,0],[0,1]], [[0,0],[1,0],[2,0]], [[0,0],[0,1],[0,2]],
    [[0,0],[1,0],[0,1],[1,1]], [[0,0],[1,0],[2,0],[3,0]], [[0,0],[0,1],[0,2],[0,3]],
    [[0,0],[1,0],[2,0],[2,1]], [[0,0],[1,0],[2,0],[0,1]], [[0,0],[0,1],[1,1]],
    [[0,0],[1,0],[1,1],[2,1]], [[1,0],[2,0],[0,1],[1,1]], [[0,0],[1,0],[2,0],[1,1]]
];

let CELL_SIZE = 0, BOARD_W = 0, BOARD_OFFSET_X = 0, BOARD_OFFSET_Y = 20, INVENTORY_Y = 0;
let BLOCK_SCALE = 0.65;

let grid = []; 
let inventory = []; 
let score = 0;
let blocksUsed = 0; 
let dragging = null;

let animState = {
    active: false,
    startTime: 0,
    rows: [],
    cols: [],
    duration: 500,
    blockToPlace: null
};

// --- 3. 初始化 ---
function resize() {
    const wrapper = document.getElementById('game-wrapper');
    const rect = wrapper.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height - 130; // 調整高度以適應UI頭部
    
    const maxBoardWidth = canvas.width - 40;
    const maxBoardHeight = canvas.height * 0.55;
    CELL_SIZE = Math.floor(Math.min(maxBoardWidth, maxBoardHeight) / GRID_SIZE);
    
    BOARD_W = CELL_SIZE * GRID_SIZE;
    BOARD_OFFSET_X = (canvas.width - BOARD_W) / 2;
    BOARD_OFFSET_Y = 20;
    INVENTORY_Y = BOARD_OFFSET_Y + BOARD_W + (canvas.height - (BOARD_OFFSET_Y + BOARD_W)) / 2 - (CELL_SIZE * 1.5);

    draw();
    if(inventory.length > 0) calcInventoryPos();
}

function initGame() {
    grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
    score = 0;
    blocksUsed = 0;
    scoreEl.innerText = "0";
    liveBlocksEl.innerText = "0"; // 重置即時顯示
    
    goOverlay.style.display = 'none';
    goOverlay.classList.remove('show');
    animState.active = false;
    
    checkDevice();
    spawnBlocks();
    requestAnimationFrame(loop);
}

function spawnBlocks() {
    inventory = [];
    for(let i=0; i<3; i++) {
        const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
        inventory.push({
            cells: shape, color: color,
            x: 0, y: 0, w: 0, h: 0,
            baseScale: BLOCK_SCALE
        });
    }
    calcInventoryPos();
    if(checkGameOver()) setTimeout(endGame, 100); 
}

function calcInventoryPos() {
    const sectionW = canvas.width / 3;
    inventory.forEach((b, i) => {
        if(!b) return;
        let mw = 0, mh = 0;
        b.cells.forEach(([x,y]) => { mw=Math.max(mw,x); mh=Math.max(mh,y); });
        
        const realCell = CELL_SIZE * b.baseScale;
        b.w = (mw+1) * realCell;
        b.h = (mh+1) * realCell;
        b.x = (sectionW * i) + (sectionW - b.w)/2;
        b.y = INVENTORY_Y;
    });
}

// --- 4. 遊戲邏輯 ---
function canPlace(cells, gc, gr) {
    for(let [x,y] of cells) {
        let nc = gc + x, nr = gr + y;
        if(nc<0 || nc>=GRID_SIZE || nr<0 || nr>=GRID_SIZE || grid[nr][nc]) return false;
    }
    return true;
}

function tryPlaceBlock(b, gc, gr, invIndex) {
    // 成功放置，計數+1
    blocksUsed++;
    liveBlocksEl.innerText = blocksUsed; // 即時更新

    b.cells.forEach(([x,y]) => grid[gr+y][gc+x] = b.color);
    
    let rows=[], cols=[];
    for(let r=0; r<GRID_SIZE; r++) if(grid[r].every(c=>c)) rows.push(r);
    for(let c=0; c<GRID_SIZE; c++) {
        let full=true;
        for(let r=0; r<GRID_SIZE; r++) if(!grid[r][c]) full=false;
        if(full) cols.push(c);
    }
    
    inventory[invIndex] = null;

    if(rows.length > 0 || cols.length > 0) {
        animState.active = true;
        animState.startTime = Date.now();
        animState.rows = rows;
        animState.cols = cols;
        animState.blockToPlace = b;
        setTimeout(finalizeClear, animState.duration);
    } else {
        score += b.cells.length;
        updateScoreDisplay();
        afterTurn();
    }
}

function finalizeClear() {
    animState.rows.forEach(r => grid[r].fill(null));
    animState.cols.forEach(c => { for(let r=0; r<GRID_SIZE; r++) grid[r][c]=null; });
    
    let count = animState.rows.length + animState.cols.length;
    score += count * 10 + (count * (count-1) * 5);
    
    updateScoreDisplay();
    animState.active = false;
    animState.rows = [];
    animState.cols = [];
    
    afterTurn();
}

function afterTurn() {
    if(inventory.every(x=>x===null)) spawnBlocks();
    if(checkGameOver()) {
        setTimeout(endGame, 500);
    }
}

function updateScoreDisplay() {
    scoreEl.innerText = score;
    scoreEl.classList.remove('pop');
    void scoreEl.offsetWidth;
    scoreEl.classList.add('pop');
}

function checkGameOver() {
    if(animState.active) return false;
    const left = inventory.filter(b=>b);
    if(left.length === 0) return false;
    for(let b of left) {
        for(let r=0; r<GRID_SIZE; r++) {
            for(let c=0; c<GRID_SIZE; c++) {
                if(canPlace(b.cells, c, r)) return false;
            }
        }
    }
    return true;
}

function endGame() {
    finalScoreEl.innerText = score;
    finalBlocksEl.innerText = blocksUsed;
    
    goOverlay.style.display = 'flex';
    setTimeout(()=> goOverlay.classList.add('show'), 10);
}

function resetGame() {
    initGame();
}

// --- 5. 輸入處理 ---
function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    const cy = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: cx - rect.left, y: cy - rect.top, isTouch: !!e.touches };
}

function onDown(e) {
    if(animState.active) return;
    if(goOverlay.classList.contains('show')) return;
    
    const p = getPos(e);
    for(let i=0; i<inventory.length; i++) {
        const b = inventory[i];
        if(!b) continue;
        const hitX = b.x - 20, hitY = b.y - 20, hitW = b.w + 40, hitH = b.h + 40;
        if(p.x >= hitX && p.x <= hitX+hitW && p.y >= hitY && p.y <= hitY+hitH) {
            e.preventDefault();
            dragging = { 
                idx: i, block: b, 
                offsetX: p.x - b.x, offsetY: p.y - b.y,
                currentX: p.x, currentY: p.y, isTouch: p.isTouch
            };
            break;
        }
    }
}

function onMove(e) {
    if(!dragging) return;
    e.preventDefault();
    const p = getPos(e);
    dragging.currentX = p.x;
    dragging.currentY = p.y;
}

function onUp(e) {
    if(!dragging) return;
    
    const b = dragging.block;
    let visX = dragging.currentX - dragging.offsetX;
    let visY = dragging.currentY - dragging.offsetY;
    if(dragging.isTouch) visY -= 80;

    const relX = visX - BOARD_OFFSET_X;
    const relY = visY - BOARD_OFFSET_Y;
    const gc = Math.round(relX / CELL_SIZE);
    const gr = Math.round(relY / CELL_SIZE);
    
    if(canPlace(b.cells, gc, gr)) {
        tryPlaceBlock(b, gc, gr, dragging.idx);
    }
    dragging = null;
}

canvas.addEventListener('mousedown', onDown);
window.addEventListener('mousemove', onMove);
window.addEventListener('mouseup', onUp);
canvas.addEventListener('touchstart', onDown, {passive: false});
window.addEventListener('touchmove', onMove, {passive: false});
window.addEventListener('touchend', onUp);

// --- 6. 繪圖 ---
function drawRoundedRect(ctx, x, y, w, h, r, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, r);
    ctx.fill();
}

function drawBlock(cells, ox, oy, size, color, alpha=1) {
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    cells.forEach(([x,y]) => {
        const px = ox + x * size;
        const py = oy + y * size;
        ctx.beginPath();
        ctx.roundRect(px+1, py+1, size-2, size-2, 6);
        ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.beginPath();
        ctx.roundRect(px+1, py+1, size-2, size/2, 6);
        ctx.fill();
        ctx.fillStyle = color;
    });
    ctx.globalAlpha = 1;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Grid BG
    for(let r=0; r<GRID_SIZE; r++) {
        for(let c=0; c<GRID_SIZE; c++) {
            drawRoundedRect(ctx, 
                BOARD_OFFSET_X + c*CELL_SIZE, 
                BOARD_OFFSET_Y + r*CELL_SIZE, 
                CELL_SIZE-2, CELL_SIZE-2, 6, "#333340");
        }
    }
    
    // Placed Blocks
    for(let r=0; r<GRID_SIZE; r++) {
        for(let c=0; c<GRID_SIZE; c++) {
            if(grid[r][c]) {
                drawRoundedRect(ctx, 
                    BOARD_OFFSET_X + c*CELL_SIZE + 1, 
                    BOARD_OFFSET_Y + r*CELL_SIZE + 1, 
                    CELL_SIZE-4, CELL_SIZE-4, 6, grid[r][c]);
            }
        }
    }
    
    // Animation Overlay
    if(animState.active) {
        const elapsed = Date.now() - animState.startTime;
        const alpha = 0.3 + 0.4 * Math.abs(Math.sin(elapsed / 50)); 
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        animState.rows.forEach(r => {
            const x = BOARD_OFFSET_X;
            const y = BOARD_OFFSET_Y + r * CELL_SIZE;
            ctx.beginPath();
            ctx.roundRect(x, y, BOARD_W, CELL_SIZE, 6);
            ctx.fill();
        });
        animState.cols.forEach(c => {
            const x = BOARD_OFFSET_X + c * CELL_SIZE;
            const y = BOARD_OFFSET_Y;
            ctx.beginPath();
            ctx.roundRect(x, y, CELL_SIZE, BOARD_W, 6);
            ctx.fill();
        });
    }

    // Inventory
    inventory.forEach((b, i) => {
        if(b && (!dragging || dragging.idx !== i)) {
            const size = CELL_SIZE * b.baseScale;
            drawBlock(b.cells, b.x, b.y, size, b.color);
        }
    });
    
    // Dragging
    if(dragging) {
        const b = dragging.block;
        let dx = dragging.currentX - dragging.offsetX;
        let dy = dragging.currentY - dragging.offsetY;
        if(dragging.isTouch) dy -= 80;
        
        const relX = dx - BOARD_OFFSET_X;
        const relY = dy - BOARD_OFFSET_Y;
        const gc = Math.round(relX / CELL_SIZE);
        const gr = Math.round(relY / CELL_SIZE);
        
        if(canPlace(b.cells, gc, gr)) {
            drawBlock(b.cells, BOARD_OFFSET_X + gc*CELL_SIZE, BOARD_OFFSET_Y + gr*CELL_SIZE, CELL_SIZE, "#FFFFFF", 0.3);
        }
        
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowBlur = 15;
        ctx.shadowOffsetY = 15;
        drawBlock(b.cells, dx, dy, CELL_SIZE, b.color);
        ctx.shadowColor = "transparent";
    }
}

function loop() {
    draw();
    requestAnimationFrame(loop);
}

initGame();

</script>
</body>
</html>